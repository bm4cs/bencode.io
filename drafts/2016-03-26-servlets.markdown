---
layout: post
title: "Servlets"
date: "2016-03-36 13:12:10"
comments: false
categories: "java"
---


Servlets advanced.

## Includes ##

Syntax:

{% highlight java %}
RequestDispatcher dispatcher = getServletContext().getRequestDispatcher("/bison");
dispatcher.include(request, response);
{% endhighlight %}

Includes are useful for injecting the content generated by another Servlet/JSP. While includes can write to the response output stream, they are unable to modify other aspects of the response such as headers and cookies for example.


{% highlight java %}
@WebServlet("/logs")
public class LogServlet extends HttpServlet {

  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    PrintWriter out = response.getWriter();
    out.println("<!DOCTYPE html><html><head><title>Log Servlet</title></head><body>");
    out.println("<h1>Log viewer Servlet</h1>");
    getServletContext().getRequestDispatcher("/bison").include(request, response);
    out.println("</body></html>");
  }
}
{% endhighlight %}



## Forwarding ##

Syntax:

{% highlight java %}
RequestDispatcher dispatcher = getServletContext().getRequestDispatcher("/bison");
dispatcher.forward(request, response);
{% endhighlight %}

Forwarding is a server side concept, where one Servlet completely delegates to another Servlet. From the clients point of view, the original resource they requested comes back as a result, and is none the wiser that a chain of server side forwards may have occured in order to accomplish the rendering.

Forwarding can be useful in pre-processing scenarios, i.e. where one Servlet might perform some function, and then hand over to another Servlet to take care of generating the response.


### Dispatcher ###

A great example that server-side forwarding enables, is the *dispatcher* pattern, for applying a common set of pre-processing a request or response. In the below example, a master page (a common template to be applied to all responses) is implemented as a dispatcher.

First the Servlet:

**DispatcherServlet.java**:

{% highlight java %}
public class DispatcherServlet extends HttpServlet {
  protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    String servletPath = request.getServletPath();
    String shortServletPath = servletPath.substring(0, servletPath.indexOf('.'));
    request.setAttribute("selectedScreen", shortServletPath);
    request.getRequestDispatcher("/template.jsp").forward(request, response);
  }
}
{% endhighlight %}

All requests are poored through `template.jsp`, which applies a common layout. In the deployment descriptor (`web.xml`), all requested with the `*.ben` suffix are configured to go through the dispatcher. The dispatcher then removes the `.ben` extension, and stores this in request scope, so later on `template.jsp` can do an include.


**template.jsp**:

{% highlight jsp %}
<%@ page errorPage="error.jsp" %>
<html>
<body>
<h1>Standard Template</h1>
<%
String selectedScreen = (String)request.getAttribute("selectedScreen");
%>
<jsp:include page="<%=selectedScreen %>"></jsp:include>
</body>
</html>
{% endhighlight %}


**web.xml**:

{% highlight xml %}
<web-app ...>
  <servlet>
    <servlet-name>dispatcher</servlet-name>
    <servlet-class>net.bencode.servlet.DispatcherServlet</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>dispatcher</servlet-name>
    <url-pattern>*.ben</url-pattern>
  </servlet-mapping>
</web-app>
{% endhighlight %}

An HTTP request such as `http://localhost:8080/app/logs.ben` will result in `template.jsp` being rendered, with an include to `/logs` (which may for example be a static resource, Servlet or JSP). Not too shabby.


## Redirection ##

Syntax:

    response.setStatus(response.SC_MOVED_PERMANENTLY);
    response.setHeader("Location", "http://slashdot.org");

Or alternatively:

    response.sendRedirect("http://slashdot.org");


## Filters ##

TODO: Flesh out from servlet advanced p31.



## Lifecycle Event Listeners ##

Allows a Servlet to be notified of interesting events that occur within the container, such as `ServletContext` startup/shutdown and attribute changes, `HttpSession` creation and modifications.

Listener interfaces:

- `ServletContextListener`: hooks for `contextInitialized` and `contextDestroyed`.
- `ServletContextAttributeListener`: hooks for `attributeAdded`, `attributeRemoved`, and `attributeReplaced`.
- `HttpSessionListener`: hooks for `sessionCreated`, `sessionDestroyed`, `sessionHttpSessionEvent`.
- `HttpSessionAttributeListener`: hooks for `attributeAdded`, `attributeRemoved` and `attributeReplaced`.
- `HttpSessionActivationListener`: hooks for `sessionWillPassivate` and `sessionDidActivate`. When the container either migrates a session between JVMs or persists sessions.


Here's the stub for a ServletContext Listener:

{% highlight java %}
public final class ContextListener
  implements ServletContextListener {

  @Override
  public void contextInitialized(ServletContextEvent event) {
    System.out.println("ServletContext has just been bootstrapped");
    event.getServletContext().setAttribute("coreDAO", ...);    
  }
  
  @Override
  public void contextDestroyed(ServletContextEvent event) {
    System.out.println("ServletContext is being destroyed");
  }
}
{% endhighlight %}

Then bind it in the deployment descriptor:

{% highlight xml %}
<web-app ...>
  <listener>
    <listener-class>net.bencode.listeners.ContextListener</listener-class>
  </listener>
</web-app>
{% endhighlight %}



## Threading Model ##

By default, a given Servlet instance can be invoked by multiple clients. Therefore is a important to prevent the family of issues that can arise from multi-threading, such as race conditions, dead locks, and inconsistent state.


### Synchronized block ###


### Pooled single thread ###



