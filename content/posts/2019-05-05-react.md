---
layout: post
title: "React"
slug: "react"
date: "2019-05-05 22:08:10"
lastmod: "2024-10-19 17:23:03"
comments: false
categories:
  - dev
  - web
tags:
  - react
---

- [React](#react)
  - [React No Frills](#react-no-frills)
- [Tools](#tools)
  - [npm](#npm)
  - [Prettier](#prettier)
  - [ESLint](#eslint)
  - [Vite](#vite)
    - [Vite Proxy](#vite-proxy)
  - [TypeScript](#typescript)
  - [Bleeding Edge and Alternative Tools](#bleeding-edge-and-alternative-tools)
- [JSX](#jsx)
  - [DOM control](#dom-control)
  - [Styling](#styling)
  - [Rendering Lists](#rendering-lists)
  - [Handling Events](#handling-events)
- [React Hooks](#react-hooks)
- [useState](#usestate)
  - [useEffect](#useeffect)
- [Passing Parameters](#passing-parameters)
- [Component Composition](#component-composition)
- [Passing Data](#passing-data)
  - [Passing Children (passing down JSX)](#passing-children-passing-down-jsx)
- [Three Rules about State](#three-rules-about-state)
- [Raising and Handling Events between Components](#raising-and-handling-events-between-components)
  - [Passing Object props](#passing-object-props)
  - [Controlled Components](#controlled-components)
- [Synchronising Components](#synchronising-components)
- [Stateless Functional Components](#stateless-functional-components)
- [Functional components](#functional-components)
- [Debugging Tips](#debugging-tips)
- [React Router](#react-router)
- [Testing](#testing)
  - [Jest](#jest)
  - [React Test Utils](#react-test-utils)
  - [Enzyme](#enzyme)
- [Gems](#gems)

## React

React is a JavaScript _library_ for building component based interactive UI's.

Unlike a fully featured framework, its up to you to deal with concerns such as routing, state management, internationalization, form validation, etc, of which React is unopinionated.

React popularised representing markup as JSX (JavaScript XML), a syntax that combines HTML and JavaScript in an expressive way, making it easier to create complex user interfaces.

At runtime React takes a tree of components and builds a JavaScript data structure called the virtual DOM. This virtual DOM is different from the actual DOM in the browser. It’s an efficient, in-memory representation of the component tree. When the state or the data of a component changes, React updates the corresponding nodes in the virtual DOM and compares it against the previous version to identify elements that need updating in the real DOM.

React (being nearly a decade old) drew inspiration from UI patterns during this era (e.g. MVC, MVVM). React collapses the model, view, and view model into a single component, encapsulating all logic for a small piece of functionality in one place. A bit like PHP does things.

### React No Frills

React can be simple.

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Padre Gino's</title>
  </head>
  <body>
    <div id="root">not rendered</div>
    <script src="https://unpkg.com/react@18.3.1/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18.3.1/umd/react-dom.development.js"></script>
    <script src="./src/App.js"></script>
  </body>
</html>
```

App.js:

```js
const Pizza = (props) => {
  return React.createElement("div", {}, [
    React.createElement("h2", {}, props.name),
    React.createElement("p", {}, props.description),
  ]);
};

const App = () => {
  var margheritaProps = {
    name: "Pizza Margherita",
    description:
      "Delicious classic pizza with tomatoes, mozzarella, and basil.",
  };

  return React.createElement("div", {}, [
    React.createElement("h1", {}, "Padre Gino's Pizza"),
    React.createElement(Pizza, margheritaProps),
    React.createElement(Pizza, {
      name: "The Hawaiian",
      description: "A tropical delight with ham and pineapple.",
    }),
  ]);
};

const container = document.getElementById("root");
const root = ReactDOM.createRoot(container);
root.render(React.createElement(App));
```

Finally serve this up with `npx serve`

## Tools

### npm

Start a fresh project with `npm init -y`, which will generate a `package.json`

- `npm install --save-dev prettier` or `npm -i -D prettier`

### Prettier

Create ` .prettierrc` to define formatting preferences, leaving this as `{}` will use default for everything.

```json
"scripts": {
  "format": "prettier --write \"src/**/*.{js,jsx,css,html}\""
},
```

### ESLint

On top of Prettier which takes of all the formatting, you may want to enforce some code styles which pertain more to usage: for example you may want to force people to never use `with` which is valid JS but ill advised to use. ESLint comes into play here. It will lint for these problems.

Install with:

```sh
npm i -D eslint@9.9.1 eslint-config-prettier@9.1.0 globals@15.9.0`

# If working with TypeScript
npm i -D @typescript-eslint/eslint-plugin @typescript-eslint/parser eslint-plugin-react eslint-plugin-react-hooks
```

[Configure](https://eslint.org/docs/latest/use/configure/configuration-files#typescript-configuration-files) by creating an `eslint.config.mjs` (as of 2025 `.eslintrc` has been deprecated).

Helpful ESLint config packages:

- `@typescript-eslint/parser`: Allows ESLint to parse TypeScript code
- `@typescript-eslint/eslint-plugin`: Provides rules specific to TypeScript
- `eslint-plugin-react`: Provides React-specific linting rules
- `eslint-plugin-react-hooks`: Enforces rules of hooks
- `eslint-config-prettier`: Turns off all ESLint rules that are unnecessary or might conflict with Prettier
- `globals` is just a big JSON file of what's available in each environment. We're going to be in Node.js and Browser environments so we grabbed those two

**Tips**:

- `/** @type {import('eslint').Linter.Config[]} */` is a VSCode trick to be able to do auto-completions on the config object
- The config objects are applied in order. We did ESLint's JS config first, and then our custom one so we can overwrite it where we want to, and then the Prettier one should always come last as all it does is turn off rules that Prettier itself does; it doesn't add anything.
- Add a script to `package.json` called `lint` that runs `eslint .`
- `npm run lint -- --fix` to auto fix lints
- `npm run lint -- --debug` to get some helpfgul

### Vite

The build tool we are going to be using today is called Vite. Vite (pronounced "veet", meaning quick in French) is a tool put out by the Vue team that ultimately ends up wrapping Rollup which does the actual bundling. The end result is a tool that is both easy to use and produces a great end result.

Install vite itself and the React specific features we will need:

```sh
npm install -D vite@5.4.2 @vitejs/plugin-react@4.3.1
```

Now we need to do some surgery, first by removing any manual React JS imports in `index.html`. We need to add `module` to the script tag `<script type="module" src="./src/App.js"></script>` so that the browser knows it's working with modern browser technology that allows you in development mode to use modules directly. Instead of having to reload the whole bundle every time, your browser can just reload the JS that has changed. It allows the browser to crawl the dependency graph itself which means Vite can run lightning fast in dev mode. It will still package it up for production so we can support a range of browsers.

Now create scripts to start Vue:

```json
"dev": "vite",
"build": "vite build",
"preview": "vite preview"
```

- `dev`: will run up a server on port `5173` (Fun fact, 5173 sort of spells VITE if you make the 5 its Roman Numeral version, V)
- `build`: will prepare static files to be deployed (to somewhere like GitHub Pages, Vercel, Netlify, AWS S3, etc.)
- `preview`: lets you preview your production build locally

Be sure to also add `"type": "module"` to your `package.json`. Vite has deprecated support for Common.js and now requires you to use ESM style modules.

#### Vite Proxy

Vite can proxy an API, this is GREAT for local dev and avoiding CORS headaches. With this config requests to `/api` and `/public` will be proxied to `localhost:3000`.

```json
export default defineConfig({
  server: {
    proxy: {
      "/api": {
        target: "http://localhost:3000",
        changeOrigin: true,
      },
      "/public": {
        target: "http://localhost:3000",
        changeOrigin: true,
      },
    },
  },
  plugins: [react()],
});
```

### TypeScript

Install React TS typedefs:

```sh
npm i -D @types/react @types/react-dom
```

When you use TypeScript with JavaScript libraries like React, TypeScript needs type definition files (`.d.ts`) to understand the types of the library's exports. The @types/react and @types/react-dom packages provide these type definitions.

These packages tell TypeScript:

- What props components accept
- What JSX elements are valid
- The types for hooks like `useState`, `useEffect`, etc.
- The types for the `jsx-runtime` module (which handles JSX transformation)

### Bleeding Edge and Alternative Tools

- `pnpm`
- [Biome](https://biomejs.dev/)
- [Oxlint](https://oxc.rs/docs/guide/usage/linter.html)

## JSX

In React, everything is just Javascript. JSX takes this to the next level, providing syntactic sugar to crunch out lots of `React.createElement`, based on a HTML-list syntax. Vite transpiles JSX into JS.

```javascript
const Pizza = (props: { name: string, description: string, image: string }) => {
  return (
    <div className="pizza">
      <h1>{props.name}</h1>
      <p>{props.description}</p>
      <img src={props.image} alt={props.name} />
    </div>
  );
};

export default Pizza;
```

### DOM control

JSX expressions must have a single parent element. As we now know, will result in a top-level parent `React.createElement()`, which can in-turn be populated with many child `React.createElement()` calls. Using a single outer `<div>` would be one option, but if you really don't want to include any outer DOM, can use the `<React.Fragment>` shown above.

### Styling

As JSX is just JS, reserved keywords like `class` and `for` cannot be used. To avoid keyword clashes alternative such as `className` as provided.

```jsx
<React.Fragment>
  <img src={this.state.imageUrl} alt="" />
  <span className="">{this.formatCount()}</span>
  <button>Increment</button>
</React.Fragment>
```

While using CSS classes is best, inline styles can be acheived by setting the `style` attribute on a JSX element to a Javascript object, like so:

```javascript
styles = {
  fontSize: 12,
  fontWeight: "bold"
};

render() {
  return (
    <React.Fragment>
      <span style={this.styles} className="badge badge-primary m-2">
        {this.formatCount()}
      </span>
```

Or using an anonymous object like this:

    <span style={{ fontSize: 30 }} className="badge badge-primary m-2">

### Rendering Lists

The `map` (higher order) function, can be used to deal with lists:

```js
class Counter extends Component {
  state = {
    count: 0,
    tags: ["tag1", "tag2", "tag3"]
  };

  render() {
    return (
      <React.Fragment>
        <ul>
          {this.state.tags.map(tag => (
            <li>{tag}</li>
          ))}
        </ul>
```

This will render a list of naked `li`, however React will throw a _warning_ in the console:

> Warning: Each child in a list should have a unique "key" prop.

In order to do virtual DOM to DOM comparison, React needs unique identifiers on everything. As there is no `id` on these `li`'s, the `key` attribute can be used:

    <li key={tag}>{tag}</li>

### Handling Events

JSX provides event handler attributes such as `onClick`:

```js
handleIncrement() {
  console.log("Increment clicked", this.state.count);
}

render() {
  return (
    <React.Fragment>
      <button
        onClick={this.handleIncrement}
        className="btn btn-secondary btn-sm"
      >
        Increment
      </button>
```



## React Hooks

## useState

In the above click handler, the `console.log` fails with:

> TypeError: this is undefined

`this` in JS is context dependent. If a method is called on an object `obj.method()` then `this` is a reference to that object. However if a function is called statically i.e. `function();` then `this` is a reference to the window object, or in strict mode `undefined`.

React rule of thumb:

> The component that owns some state, should be responsible for mutating it.

Just use an arrow function:

```js
handleIncrement = () => {
  console.log("Increment clicked", this.state.count);
};
```

Now that the event handler has `this` access, cannot just start mutating it, for example `this.state.count++` will not affect the UI, as React is not aware that this custom piece of state has changed, and what is impacted by the state change.

To change state, React provides `setState`:

```js
handleIncrement = () => {
  this.setState({ count: this.state.count + 1 });
};
```


### useEffect

Effects were introduced in early 2019, and give function components the same degree of hooks as class components.

```javascript
import React, { useEffect } from "react";
...
function ManageCoursesPage({ courses, authors, loadCourses, loadAuthors }) {
  useEffect(() => {
    if (courses.length === 0) {
      loadCourses().catch((error) => {
        alert("Loading courses failed " + error);
      });
    }

    if (authors.length === 0) {
      loadAuthors().catch((error) => {
        alert("Loading authors failed " + error);
      });
    }
  }, []);
  // The 2nd param is list of items to monitor, if they change, fire the effect.
  // An empty array causes the effect to only fire once (i.e. like componentDidMount)

  return (
    <>
      <h2>Manage Course</h2>
    </>
  );
}
```

Some highlights:

- The props destructuring happens right in the function signature.
- `componentDidMount` is replaced with `useEffect`
- No need for an explicit `render`, as its implied in a functional component



## Passing Parameters

It is common to want to pass some state along to the event handler, when its invoked.

One option is to create a wrapper function:

```javascript
handleIncrement = product => {
  console.log(product);
  this.setState({ count: this.state.count + 1 });
};

doHandleIncrement = () => {
  this.handleIncrement({ id: 1 });
};

render() {
  return (
    <React.Fragment>
      <button
        onClick={this.doHandleIncrement}
        className="btn btn-secondary btn-sm"
      >
        Increment
      </button>
```

For consiseness wrapper function can be represented as an inline (arrow) function:

```javascript
<button
  onClick={() => this.handleIncrement({ id: 1 })}
  className="btn btn-secondary btn-sm"
>
  Increment
</button>
```

## Component Composition

A React app is a tree of components. In `index.js` is kicked off with the:

    ReactDOM.render(<Counter />, document.getElementById("root"));

To compose many `Counter` components, one option is to create an outer `Counters` component:

```javascript
import React, { Component } from "react";
import Counter from "./counter";

class Counters extends Component {
  state = {
    counters: [
      { id: 1, value: 0 },
      { id: 2, value: 0 },
      { id: 3, value: 0 },
      { id: 4, value: 0 },
    ],
  };

  render() {
    return (
      <div>
        {this.state.counters.map((c) => (
          <Counter key={c.id} />
        ))}
      </div>
    );
  }
}

export default Counters;
```

## Passing Data

While the above `Counters` component successfully composes several `Counter`'s from a list, it does not pass state to the child components.

State can be propagated to child components, as attribute like so:

    <Counter key={c.id} value={c.value} selected={true} />

This state is exposed to the target components as `props`. A console log in child component `Counter` render method:

    render() {
      console.log("props", this.props);

Results in:

    props Object { value: 0, selected: true, … }
    props Object { value: 0, selected: true, … }
    props Object { value: 3, selected: true, … }
    props Object { value: 0, selected: true, … }

`props` can be used throughout the component, and even directly in the component `state`, like so:

    class Counter extends Component {
      state = {
        count: this.props.value,
        tags: ["tag1", "tag2", "tag3"],
        imageUrl: "https://picsum.photos/200",
        address: {
          street: ""
        }
      };

### Passing Children (passing down JSX)

Previously the `Counters` component, composed many `Counter` instances, like so, while defining a few `props`:

    <div>
      {this.state.counters.map(c => (
        <Counter key={c.id} value={c.value} selected={true} />
      ))}
    </div>

To make components even more useful, its possible to pass in inner JSX content, for example:

    <Counter key={c.id} value={c.value} selected={true}>
      <h2>semaphore</h2>
    </Counter>

The `props` of the child component, exposes this `h2` via a list called `children`:

    props {…}
            children: {…}
              "$$typeof": Symbol(react.element)
              _owner: Object { tag: 1, key: null, index: 0, … }
              _self: Object { props: {}, context: {}, refs: {}, … }
              _source: Object { fileName: "./src/components/counters.jsx", lineNumber: 19 }
              _store: Object { … }
              key: null
              props: Object { children: "semaphore" }
              ref: null
              type: "h2"
              <prototype>: Object { … }
            key:
            selected: true
            value: 0
            <get key()>: function warnAboutAccessingKey()
            <prototype>: {…

To make use of the `props.children` property is easy:

    render() {
      return (
        <React.Fragment>
          {this.props.children}
          <span className={this.getBadgeClasses()}>{this.formatCount()}</span>

This will render the children as defined in the calling component, in this case an `h2` tag will be emitted.

Interestingly `props` are immutable, and can't be modified, `state` should be used.

## Three Rules about State

**Rule 1**: Never modify `state` directly, always use `setState()`.

**Rule 2**: State updates are asynchronous, as a result the correct values of `this.props` and `this.state` at the time they are queried, can't always be guaranteed. The second form of `setState()` that accepts a function (not the usual object) should be used.

```js
this.setState((state, props) => ({
  counter: state.counter + props.increment
}));
```

**Rule 3**: State updates are magically merged. State might contain several variables:

```js
constructor(props) {
  super(props);
  this.state = {
    posts: [],
    comments: []
  };
}
```

Individual variables can be updated independently, with separate `setState()` calls, without clobbering.

```js
componentDidMount() {
  fetchPosts().then(response => {
    this.setState({
      posts: response.posts
    });
  });

  fetchComments().then(response => {
    this.setState({
      comments: response.comments
    });
  });
}
```

## Raising and Handling Events between Components

State management rule of thumb:

> The component that owns some state, should be responsible for mutating it.

A common scenario is for parent or outer components to define the state that is consumed by downstream components. Given the rule of thumb above, how should a downstream component go about modifying the original state?

One good option is the _observer pattern_, in which a child component raises an event, which can be handled by its parent component to react and respond to a state change.

For example, the `Counters` component defines several `Counter` components. A component can elect to delete itself by displaying a delete button to the user. If clicked, the `Counter` instance could raise an `onDelete` event. `Counters` could handle this event with `handleDelete()`.

In the `Counters` component:

- create event handler e.g. `handleDelete` responsible for mutating the original state that relates to the event. _important_ in React, you can't just mutate state and expect React to know about it, instead you must reassign the state using Reacts `setState` function (see below)
- pass this handler function downstream to `Counter` components as `props`

  class Counters extends Component {
  state = {
  counters: [
  { id: 1, value: 0 },
  { id: 2, value: 0 },
  { id: 3, value: 3 },
  { id: 4, value: 2 }
  ]
  };

      handleDelete = counterId => {
        console.log("Event handler called", counterId);
        const counters = this.state.counters.filter(c => c.id !== counterId);
        this.setState({ counters: counters });
      };

      render() {
        return (
          <div>
            {this.state.counters.map(c => (
              <Counter
                key={c.id}
                value={c.value}
                onDelete={this.handleDelete}
                selected={true}
              />
            ))}
          </div>

Using the _React Developer Tools_ browser extension, can drill down into `Counters` to an individual `Counter` instance, and check out its Props (right hand panel) - note the `onDelete` prop:

    Props
      onDelete: handleDelete()
      selected: true
      value: 0

In the `Counter` component, simply need to wire in the `onDelete` now available in `props` to the `onClick`:

    <button
      onClick={() => this.props.onDelete(this.props.id)}
      className="btn btn-danger btn-sm m-2"
    >

### Passing Object props

Over time, the number of individual `props` defined may continue to swell, like so:

    <Counter
      key={c.id}
      value={c.value}
      onDelete={this.handleDelete}
      selected={true}
    />

Instead, of mapping each field as a prop, why not pass the entire object (in this case called `counter`) along:

    <Counter
      key={counter.id}
      counter={counter}
    />

Make sure to update affected `props` reference in the child components:

    class Counter extends Component {
      state = {
        count: this.props.counter.value,
        ...

### Controlled Components

Local state within components, can cause components to get out of wack. For example, when setting the initial `state` of a child component from `props` only happens when the component is created. Future changes to state in the parent, that was passed down as `props` to its children, will not flow through after initial creation.

A _controlled component_ is one that:

- Receives essential data needed to render via `props` from its parent.
- Never manages this as `state` locally, but instead fires events to request the data be updated back in the parent.

Refactoring steps:

- Remove any local `state`
- Any references to `this.state` should be updated to use `props` directly, and trigger events to communicate with the parent (observer) where needed.

For example, this button now delegates its click handler to a func passed through by its housing (parent) component:

    <button
      onClick={() => this.props.onIncrement(this.props.counter)}
      className="btn btn-secondary btn-sm"
    >

## Synchronising Components

Sometimes, as the architecture of the view changes, new components get introduced. This can modify the shape of the component tree.

For example, introducing a navbar component that requires access to the state of another _unrelated_ component.

The general pattern for this is known as _lifting the state_ upwards. The higher in the tree the state lives, the more widely it can be propagated down the various branches.

The `Counters` component used to be responsible for managing the `counters` in its own `state`, rendering each child `Counter` component. Lifting this state upwards to top level `App` component, means refactoring `this.state` access with `this.props` accessors. Event handlers must bubble upwards too:

    <Counter
      key={c.id}
      counter={c}
      onDelete={this.props.onDelete}
      onIncrement={this.props.onIncrement}
      selected={true}

In the top level `App` component, the render can now propagate state as needed, for example only passing the `totalCounters` to the `NavBar` component, while passing down the full counter objects to `Counters`:

    render() {
      return (
        <React.Fragment>
          <NavBar
            totalCounters={this.state.counters.filter(c => c.value > 0).length}
          />
          <main className="container">
            <Counters
              counters={this.state.counters}
              onReset={this.handleReset}
              onDelete={this.handleDelete}
              onIncrement={this.handleIncrement}
            />
          </main>
        </React.Fragment>
      );
    }

## Stateless Functional Components

When a component is simple enough to contain only a `render`. No supporting funcs or logic. No object state (i.e. `props` only access to data).

The following NavBar component is a prime candidate for conversion:

```js
class NavBar extends Component {
  render() {
    return (
      <nav className="navbar navbar-light bg-light">
        <a className="navbar-brand" href="#">
          Cool React App{" "}
          <span className="badge badge-pill badge-secondary">
            {this.props.totalCounters}
          </span>
        </a>
      </nav>
    );
  }
}
```

Converting a class based component to functional, involves simply defining the component as an arrow function that returns a JSX element. Any use of object `this` state such as `this.props`, need to be defined as parameters on the arrow function (`props` will be dependency injected automatically).

```js
const NavBar = (props) => {
  return (
    <nav className="navbar navbar-light bg-light">
      <a className="navbar-brand" href="#">
        Cool React App{" "}
        <span className="badge badge-pill badge-secondary">
          {props.totalCounters}
        </span>
      </a>
    </nav>
  );
};
```

To simplify the constant need to prefix `props.`, can leverage ES6 argument destructuring to tear apart the individual data fields.

```js
const NavBar = ({totalCounters}) => {
  return (
    <nav className="navbar navbar-light bg-light">
      <a className="navbar-brand" href="#">
        Cool React App{" "}
        <span className="badge badge-pill badge-secondary">
          {totalCounters}
        </span>
```


## Functional components

`const NavBar = (props) => {` becomes `const NavBar = ({ totalCounters }) => {`

Resulting in cleaner `prop` access:

```js
const NavBar = ({ totalCounters }) => {
  return (
    <nav className="navbar navbar-light bg-light">
      <a className="navbar-brand" href="#">
        Cool React App{" "}
        <span className="badge badge-pill badge-secondary">
          {totalCounters}
        </span>
      </a>
    </nav>
  );
};
```




## Debugging Tips

Get the _React Developer Tools_ Chrome or FF extension.

Using the newly provided _React_ tab within dev tools, will now be able to clearly view the tree hierarchy of React components.

Component in this view are selectable, and will be assigned to variable `$r`, like so:

    <Counters>
      <div>
        <Counter key="1" value={0} selected={true}>...</Counter> == $r
        <Counter key="2" value={0} selected={true}>...</Counter>
        <Counter key="3" value={3} selected={true}>...</Counter>
        <Counter key="4" value={2} selected={true}>...</Counter>
      </div>
    </Counters>

In the same way selecting a piece of DOM with the _Elements_ tab would assign it to `$0`. Using the `$r` reference in the _Console_ can begin to inspect and play with it:

- call its `render()`
-

## React Router

SPA web frameworks render components based on some state, making them appear like multiple pages. This is not the case.

React Router adds the notion of conditionally rendering components based on the _route_ specified in the URI, such as `/` for home, `/about` for the about page, and so on.

Benefits of faking routes and pages in a SPA:

- aids crawlers (SEO) to walk the site hierarchy,
- bookmarkable URL's,
- reduces the initial design overhead of planning out the state/props to facilitate component rendering (i.e. can lean on the router)

React Router makes this possible by provides a set of navigation components:

- `BrowserRouter`
- `HashRouter`
- `Link` provides declarative navigation around your application. Note the use of backticks for setting the `to` prop with actual state:

    <Link to={`/g/${gist.id}`}>

Install the package:

    $ yarn install react-router-dom

Import to the (top level) component responsible for rendering the content portion of the app (e.g. `App.js`):

    import { BrowserRouter } from 'react-router-dom'

Or optionally alias it to the slicker `Router`:

    import { BrowserRouter as Router } from 'react-router-dom'

Wrap everything in the `render()` with the `BrowserRouter` component:

```js
render() {
  return (
    <BrowserRouter>
      <NavBar
        totalCounters={this.state.counters.map(a => a.value).reduce((accumulator, currentValue) => accumulator + currentValue)}
      />

      <div className="d-flex" id="wrapper">
        <SideBar />

        <div id="page-content-wrapper">
          <div className="container-fluid">
            <Counters
              counters={this.state.counters}
              onReset={this.handleReset}
              onDelete={this.handleDelete}
              onIncrement={this.handleIncrement}
            />
          </div>
        </div>
      </div>
    </BrowserRouter>
  );
}
```

Roll out the `Link` component, to parts of the UI that should influence the routes (e.g. a sidebar or nav menu for changing pages). Here is my custom `SideBar` component:

```js
render() {
  const { gists } = this.state;

  return (
    <div className="bg-light border-right" id="sidebar-wrapper">
      <div className="sidebar-heading">Router Fun</div>
      <div className="list-group list-group-flush">
        { gists ? (
              gists.filter(gist => gist.description !== '').map(gist => (
                <Link to={`/g/${gist.id}`} className="list-group-item list-group-item-action bg-light">
                  {gist.description}
                </Link>
              ))
            ) : (
              <div>Loading...</div>
            )}
      </div>
    </div>
  );
}
```

Now back in the top level component using the `BrowserRouter` component, register some `Route`s:

```js
render() {
  return (
    <BrowserRouter>
      <React.Fragment>
        <div className="d-flex" id="wrapper">
          <SideBar gists={this.state.gists} />

          <div id="page-content-wrapper">
            <div className="container-fluid">
              <Route path="/g/:gistId" component={Gist}></Route>
```

Clicking a `Link` will change the URI to something like `/g/77501744874a981e61c86ba3edfb4a46` (the gist id), the route will match, which will render the `Gist` component:

```js
import React, { Component } from "react";

const Gist = ({ match }) => (
  <div className="container">
    <h1>{match.params.gistId}</h1>
  </div>
);

export default Gist;
```

I want a home page to render at `/`. Back in the `BrowserRouter`, register a new `/` `Route`:

```js
<Route
  path="/"
  exact={true}
  render={(props) => (
    <Home
      {...props}
      counters={this.state.counters}
      onReset={this.handleReset}
      onDelete={this.handleDelete}
      onIncrement={this.handleIncrement}
    />
  )}
/>
```

This is a `render` route, unlike the previous component route that was used. As you can see, allows you to bind custom props, in addition to the 3 route props (preserved with the spread operator). Note, the `exact` prop here prevents this route from matching whenever there is a leading forward slash `/` (basically every URL). Exact, you guessed it, forces an exact match of a single `/`. Working this second home route into the existing `BrowserRouter`:

```js
render() {
  return (
    <BrowserRouter>
      <React.Fragment>
        <div className="d-flex" id="wrapper">
          <SideBar gists={this.state.gists} />

          <div id="page-content-wrapper">
            <div className="container-fluid">

              <Route path="/" exact={true} render={(props) =>
                  <Home {...props}
                    counters={this.state.counters}
                    onReset={this.handleReset}
                    onDelete={this.handleDelete}
                    onIncrement={this.handleIncrement} />} />

              <Route path="/g/:gistId" component={Gist}></Route>
```

react-router also features a `redirect` component.

```javascript
import { Redirect } from "react-router-dom";

class CoursesPage extends React.Component {
  state = {
    redirectToAddCoursePage: false,
  };

  render() {
    return (
      <>
        {this.state.redirectToAddCoursePage && <Redirect to="/course" />}
        <h2>Courses</h2>
        <button
          style={{ marginBottom: 20 }}
          className="btn btn-primary add-course"
          onClick={() => this.setState({ redirectToAddCoursePage: true })}
        >
          Add Course
        </button>

        <CourseList courses={this.props.courses} />
      </>
    );
  }
}
```

It's also possible to use react-routers history to change the URL to a location. Any component routed by `react-router` will automatically be injected with a `history` prop.

Before:

```javascript
function handleSave(event) {
  event.preventDefault();
  saveCourse(course);
}
```

After:

```javascript
function handleSave(event) {
  event.preventDefault();
  saveCourse(course).then(() => {
    history.push("/courses");
  });
}
```

## Testing

React by design is incredibly testable, something that was difficult in traditional server-side technologies. For example, its possible to render a single component against an in-memory DOM and fake click events, to test a component behaves as expected.

Like everything in the react ecosystem, there are lots of choices.

Popular testing frameworks include _jest_ (facebook and bundled with CRA), _mocha_ (very configurable with large ecosystem), _jasmine_ (like mocha but slighly less configurable), _tape_ (minimalist) and _AVA_.

Helper libraries exist to aid verification of components, such as mocking and shallow rendering (not rendering the child hierarchy). Popular options include [ReactTestUtils](https://reactjs.org/docs/test-utils.html), [Enzyme](https://airbnb.io/projects/enzyme/) and [React testing library]().

### Jest

Setup an npm script runner for jest:

```json
{
  "name": "ps-redux",
  "description": "React and Redux Pluralsight course by Cory House",
  "scripts": {
    "start": "run-p start:dev start:api",
    "start:dev": "webpack-dev-server --config webpack.config.dev.js --port 3000",
    "prestart:api": "node tools/createMockDb.js",
    "start:api": "node tools/apiServer.js",
    "test": "jest --watch"
  },
  "jest": {
    "setupFiles": [
      "./tools/testSetup.js"
    ],
    "moduleNameMapper": {
      "\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga)$": "<rootDir>/tools/fileMock.js",
      "\\.(css|less)$": "<rootDir>/tools/styleMock.js"
    }
  },

```

The `fileMock.js` and `styleMock.js` provide a testing hook for when files of a particular type get consumed by the rendering process.

Jest automatically searches for tests in files that end in `.test.js` or `.spec.js`, here's a test in a file called `index.test.js`:

```javascript
it("should pass", () => {
  expect(true).toEqual(true);
});
```

Snapshot testing with jest, captures the rendered output of components, and compares the output over time to ensure regressions havent slipped in.

A benefit of setting up mockdata with something like [JSON Server](https://github.com/typicode/json-server) is that the same mock data can be used in the unit tests.

```javascript
import React from "react";
import CourseForm from "./CourseForm";
import renderer from "react-test-renderer";
import { courses, authors } from "../../../tools/mockData";

it("sets submit button label to 'Saving...' when saving prop is true", () => {
  const tree = renderer.create(
    <CourseForm
      course={courses[0]}
      authors={authors}
      onChange={jest.fn()}
      onSave={jest.fn()}
      saving={true}
    />
  );

  expect(tree).toMatchSnapshot();
});

it("sets submit button label to 'Save' when saving prop is false", () => {
  const tree = renderer.create(
    <CourseForm
      course={courses[0]}
      authors={authors}
      onChange={jest.fn()}
      onSave={jest.fn()}
      saving={false}
    />
  );

  expect(tree).toMatchSnapshot();
});
```

Running this will result in jest creating an `__snapshots__` directory next to the test file, with the output of the rendered DOM.

`jest.fn()` creates an empty function, to save you the effort, so you can stub any function props.

Now with the snapshots captured, these could be committed into your git repo, and verified as part of your CI pipeline. If for example, the label of the save button changed or the logic basec on the `saving` prop broken the snapshot test would fail.

Jest in watch mode provides a bunch of options:

Watch Usage

- Press a to run all tests.
- Press f to run only failed tests.
- Press p to filter by a filename regex pattern.
- Press t to filter by a test name regex pattern.
- Press q to quit watch mode.
- Press u to update failing snapshots.
- Press Enter to trigger a test run.

### React Test Utils

Takes two approaches to component rendering; `shallowRender` and `renderIntoDocument`.

`shallowRender` will render only a single component (not child components) which is useful for asserting the coupling to other components and has no dependency on an actual DOM. Not having a DOM doesn't work for all scenarios, particularly things like button click events.

`renderIntoDocument` will do a full component (and its children) render, and requires a DOM. Requiring a DOM doesn't necessary mean a browser however, with headless DOM libs like [jsdom](https://github.com/jsdom/jsdom).

> jsdom is a pure-JavaScript implementation of many web standards, for use with Node.js

Some examples of its [API]() are `scryRenderedDOMComponentsWithClass()`, `findRenderedDOMComponentWithClass()`, `scryRenderedDOMComponentsWithTag()`, `findRenderedDOMComponentWithTag()`. The `scry` variants finds all DOM elements of components in the rendered tree that match, while the `find` variants expects only a single result.

The `Simulate` function allows you to fake DOM events such as key pressing or clicking an element:

```javascript
const node = this.button;
ReactTestUtils.Simulate.click(node);
```

### Enzyme

An wrapper by airbnb that includes `ReactTestUtils`, `JSDOM` (in-memory DOM) and Cheerio (CSS selector support), provides a simplified, headless testing environment and API. For example, it provides a single `find` function that accepts CSS style selectors.

```javascript
describe('<MyComponent />', () => {
  it('renders three <Foo /> components', () => {
    const wrapper = shallow(<MyComponent />);
    expect(wrapper.find(Foo)).to.have.lengthOf(3);
  });
```

Enzyme offers a few rending methods:

- Shallow rendering: `shallow()`, no DOM, no child components, fast
- Full DOM rendering: `mount()`, in-memory DOM with JSDOM, child components rendered, slow
- Static rendering

To setup enzyme an adapter specific to the version of react you're running needs to be bootstrapped `./tools/testSetup.js`:

```javascript
import { configure } from "enzyme";
import Adapter from "enzyme-adapter-react-16";
configure({ adapter: new Adapter() });
```

Configure jest to hook this in `package.json`:

```json
  "jest": {
    "setupFiles": [
      "./tools/testSetup.js"
    ],
```

Create a file that ends in `.test.js` for jest to pick it up, putting enzyme in the name is a nice touch ex: `CourseForm.Enzyme.test.js`:

```javascript
import React from "react";
import CourseForm from "./CourseForm";
import { shallow } from "enzyme";

function renderCourseForm(args) {
  const defaultProps = {
    authors: [],
    course: {},
    saving: false,
    errors: {},
    onSave: () => {},
    onChange: () => {},
  };

  const props = { ...defaultProps, ...args };
  return shallow(<CourseForm {...props} />);
}

it("renders form and header", () => {
  const wrapper = renderCourseForm();
  // console.log(wrapper.debug());
  expect(wrapper.find("form").length).toBe(1);
  expect(wrapper.find("h2").text()).toEqual("Add Course");
});

it('labels save buttons as "Save" when not saving', () => {
  const wrapper = renderCourseForm();
  expect(wrapper.find("button").text()).toBe("Save");
});

it('labels save button as "Saving..." when saving', () => {
  const wrapper = renderCourseForm({ saving: true });
  expect(wrapper.find("button").text()).toBe("Saving...");
});
```

The `renderCourseForm()` cuts down on props wrangling boilerplate code, that each test would need to setup.

Finally to contrast shallow versus full DOM rendering that enzyme supports:

```javascript
import React from "react";
import Header from "./Header";
import { mount, shallow } from "enzyme";
import { MemoryRouter } from "react-router-dom";

// Note how with shallow render you search for the React component tag
it("contains 3 NavLinks via shallow", () => {
  const numLinks = shallow(<Header />).find("NavLink").length;
  expect(numLinks).toEqual(3);
});

// Note how with mount you search for the final rendered HTML since it generates the final DOM.
// We also need to pull in React Router's memoryRouter for testing since the Header expects to have React Router's props passed in.
it("contains 3 anchors via mount", () => {
  const numAnchors = mount(
    <MemoryRouter>
      <Header />
    </MemoryRouter>
  ).find("a").length;

  expect(numAnchors).toEqual(3);
});
```



## Gems

- [Complete Intro to React v9 (2024 refresh) by Brian Holt](https://react-v9.holt.courses/)
- [citr-v9-project](https://github.com/btholt/citr-v9-project)
- Keep render paths within components as lean as possible, as they are often hot paths being run many times. This is the most common cause of CLS (Cumulative Layout Shift) quantifies the amount of unexpected layout shifts that occur during the lifespan of a web page.