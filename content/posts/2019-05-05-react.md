---
layout: post
title: "React"
slug: "react"
date: "2019-05-05 22:08:10"
lastmod: "2024-10-19 17:23:03"
comments: false
categories:
  - dev
  - web
tags:
  - react
---

- [React](#react)
  - [React No Frills](#react-no-frills)
- [Tools](#tools)
  - [npm](#npm)
  - [Prettier](#prettier)
  - [ESLint](#eslint)
  - [Vite](#vite)
    - [Vite Proxy](#vite-proxy)
  - [TypeScript](#typescript)
  - [Bleeding Edge and Alternative Tools](#bleeding-edge-and-alternative-tools)
- [JSX](#jsx)
  - [DOM control](#dom-control)
  - [Styling](#styling)
  - [Rendering Lists](#rendering-lists)
  - [Handling Events](#handling-events)
- [React Hooks](#react-hooks)
  - [useState](#usestate)
  - [useEffect](#useeffect)
  - [Custom Hooks](#custom-hooks)
  - [useContext](#usecontext)
- [Forms and User Input](#forms-and-user-input)
  - [Push Cart to Server](#push-cart-to-server)
- [Passing Parameters to Event Handlers](#passing-parameters-to-event-handlers)
  - [Passing JSX as Props](#passing-jsx-as-props)
- [Raising and Handling Events between Components](#raising-and-handling-events-between-components)
- [Resources](#resources)

## React

React is a JavaScript _library_ for building component based interactive UI's.

Unlike a fully featured framework, its up to you to deal with concerns such as routing, state management, internationalization, form validation, etc, of which React is unopinionated.

React popularised representing markup as JSX (JavaScript XML), a syntax that combines HTML and JavaScript in an expressive way, making it easier to create complex user interfaces.

At runtime React takes a tree of components and builds a JavaScript data structure called the virtual DOM. This virtual DOM is different from the actual DOM in the browser. Itâ€™s an efficient, in-memory representation of the component tree. When the state or the data of a component changes, React updates the corresponding nodes in the virtual DOM and compares it against the previous version to identify elements that need updating in the real DOM.

React (being nearly a decade old) drew inspiration from UI patterns during this era (e.g. MVC, MVVM). React collapses the model, view, and view model into a single component, encapsulating all logic for a small piece of functionality in one place. A bit like PHP does things.

### React No Frills

React can be simple.

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Padre Gino's</title>
  </head>
  <body>
    <div id="root">not rendered</div>
    <script src="https://unpkg.com/react@18.3.1/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18.3.1/umd/react-dom.development.js"></script>
    <script src="./src/App.js"></script>
  </body>
</html>
```

App.js:

```js
const Pizza = (props) => {
  return React.createElement("div", {}, [
    React.createElement("h2", {}, props.name),
    React.createElement("p", {}, props.description),
  ]);
};

const App = () => {
  var margheritaProps = {
    name: "Pizza Margherita",
    description:
      "Delicious classic pizza with tomatoes, mozzarella, and basil.",
  };

  return React.createElement("div", {}, [
    React.createElement("h1", {}, "Padre Gino's Pizza"),
    React.createElement(Pizza, margheritaProps),
    React.createElement(Pizza, {
      name: "The Hawaiian",
      description: "A tropical delight with ham and pineapple.",
    }),
  ]);
};

const container = document.getElementById("root");
const root = ReactDOM.createRoot(container);
root.render(React.createElement(App));
```

Finally serve this up with `npx serve`

## Tools

### npm

Start a fresh project with `npm init -y`, which will generate a `package.json`

- `npm install --save-dev prettier` or `npm -i -D prettier`

### Prettier

Create ` .prettierrc` to define formatting preferences, leaving this as `{}` will use default for everything.

```json
"scripts": {
  "format": "prettier --write \"src/**/*.{js,jsx,css,html}\""
},
```

### ESLint

On top of Prettier which takes of all the formatting, you may want to enforce some code styles which pertain more to usage: for example you may want to force people to never use `with` which is valid JS but ill advised to use. ESLint comes into play here. It will lint for these problems.

Install with:

```sh
npm i -D eslint@9.9.1 eslint-config-prettier@9.1.0 globals@15.9.0`

# If working with TypeScript
npm i -D @typescript-eslint/eslint-plugin @typescript-eslint/parser eslint-plugin-react eslint-plugin-react-hooks
```

[Configure](https://eslint.org/docs/latest/use/configure/configuration-files#typescript-configuration-files) by creating an `eslint.config.mjs` (as of 2025 `.eslintrc` has been deprecated).

Helpful ESLint config packages:

- `@typescript-eslint/parser`: Allows ESLint to parse TypeScript code
- `@typescript-eslint/eslint-plugin`: Provides rules specific to TypeScript
- `eslint-plugin-react`: Provides React-specific linting rules
- `eslint-plugin-react-hooks`: Enforces rules of hooks
- `eslint-config-prettier`: Turns off all ESLint rules that are unnecessary or might conflict with Prettier
- `globals` is just a big JSON file of what's available in each environment. We're going to be in Node.js and Browser environments so we grabbed those two

**Tips**:

- `/** @type {import('eslint').Linter.Config[]} */` is a VSCode trick to be able to do auto-completions on the config object
- The config objects are applied in order. We did ESLint's JS config first, and then our custom one so we can overwrite it where we want to, and then the Prettier one should always come last as all it does is turn off rules that Prettier itself does; it doesn't add anything.
- Add a script to `package.json` called `lint` that runs `eslint .`
- `npm run lint -- --fix` to auto fix lints
- `npm run lint -- --debug` to get some helpfgul

### Vite

The build tool we are going to be using today is called Vite. Vite (pronounced "veet", meaning quick in French) is a tool put out by the Vue team that ultimately ends up wrapping Rollup which does the actual bundling. The end result is a tool that is both easy to use and produces a great end result.

Install vite itself and the React specific features we will need:

```sh
npm install -D vite@5.4.2 @vitejs/plugin-react@4.3.1
```

Now we need to do some surgery, first by removing any manual React JS imports in `index.html`. We need to add `module` to the script tag `<script type="module" src="./src/App.js"></script>` so that the browser knows it's working with modern browser technology that allows you in development mode to use modules directly. Instead of having to reload the whole bundle every time, your browser can just reload the JS that has changed. It allows the browser to crawl the dependency graph itself which means Vite can run lightning fast in dev mode. It will still package it up for production so we can support a range of browsers.

Now create scripts to start Vue:

```json
"dev": "vite",
"build": "vite build",
"preview": "vite preview"
```

- `dev`: will run up a server on port `5173` (Fun fact, 5173 sort of spells VITE if you make the 5 its Roman Numeral version, V)
- `build`: will prepare static files to be deployed (to somewhere like GitHub Pages, Vercel, Netlify, AWS S3, etc.)
- `preview`: lets you preview your production build locally

Be sure to also add `"type": "module"` to your `package.json`. Vite has deprecated support for Common.js and now requires you to use ESM style modules.

#### Vite Proxy

Vite can proxy an API, this is GREAT for local dev and avoiding CORS headaches. With this config requests to `/api` and `/public` will be proxied to `localhost:3000`.

```json
export default defineConfig({
  server: {
    proxy: {
      "/api": {
        target: "http://localhost:3000",
        changeOrigin: true,
      },
      "/public": {
        target: "http://localhost:3000",
        changeOrigin: true,
      },
    },
  },
  plugins: [react()],
});
```

### TypeScript

Install React TS typedefs:

```sh
npm i -D @types/react @types/react-dom
```

When you use TypeScript with JavaScript libraries like React, TypeScript needs type definition files (`.d.ts`) to understand the types of the library's exports. The @types/react and @types/react-dom packages provide these type definitions.

These packages tell TypeScript:

- What props components accept
- What JSX elements are valid
- The types for hooks like `useState`, `useEffect`, etc.
- The types for the `jsx-runtime` module (which handles JSX transformation)

### Bleeding Edge and Alternative Tools

- `pnpm`
- [Biome](https://biomejs.dev/)
- [Oxlint](https://oxc.rs/docs/guide/usage/linter.html)

## JSX

In React, everything is just Javascript. JSX takes this to the next level, providing syntactic sugar to crunch out lots of `React.createElement`, based on a HTML-list syntax. Vite transpiles JSX into JS.

```javascript
const Pizza = (props: { name: string, description: string, image: string }) => {
  return (
    <div className="pizza">
      <h1>{props.name}</h1>
      <p>{props.description}</p>
      <img src={props.image} alt={props.name} />
    </div>
  );
};

export default Pizza;
```

### DOM control

JSX expressions must have a single parent element. As we now know, will result in a top-level parent `React.createElement()`, which can in-turn be populated with many child `React.createElement()` calls. Using a single outer `<div>` would be one option, but if you really don't want to include any outer DOM, can use the `<React.Fragment>` shown above.

### Styling

As JSX is just JS, reserved keywords like `class` and `for` cannot be used. To avoid keyword clashes alternative such as `className` as provided.

```jsx
<React.Fragment>
  <img src={this.state.imageUrl} alt="" />
  <span className="">{this.formatCount()}</span>
  <button>Increment</button>
</React.Fragment>
```

While using CSS classes is best, inline styles can be acheived by setting the `style` attribute on a JSX element to a Javascript object, like so:

```javascript
styles = {
  fontSize: 12,
  fontWeight: "bold"
};

render() {
  return (
    <React.Fragment>
      <span style={this.styles} className="badge badge-primary m-2">
        {this.formatCount()}
      </span>
```

Or using an anonymous object like this:

    <span style={{ fontSize: 30 }} className="badge badge-primary m-2">

### Rendering Lists

The `map` (higher order) function, can be used to deal with lists:

```js
class Counter extends Component {
  state = {
    count: 0,
    tags: ["tag1", "tag2", "tag3"]
  };

  render() {
    return (
      <React.Fragment>
        <ul>
          {this.state.tags.map(tag => (
            <li>{tag}</li>
          ))}
        </ul>
```

This will render a list of naked `li`, however React will throw a _warning_ in the console:

> Warning: Each child in a list should have a unique "key" prop.

In order to do virtual DOM to DOM comparison, React needs unique identifiers on everything. As there is no `id` on these `li`'s, the `key` attribute can be used:

    <li key={tag}>{tag}</li>

### Handling Events

JSX provides event handler attributes such as `onClick`:

```js
handleIncrement() {
  console.log("Increment clicked", this.state.count);
}

render() {
  return (
    <React.Fragment>
      <button
        onClick={this.handleIncrement}
        className="btn btn-secondary btn-sm"
      >
        Increment
      </button>
```

## React Hooks

A hook called such because it's a hook that gets caught every time the render function gets called. Because the hooks get called in the same order every single time, they'll always point to the same piece of state. Because of that they can be stateful: you can keep pieces of mutable state using hooks and then modify them later using their provided updater functions.

An **absolutely critical** concept for you to grasp is hooks rely on this strict ordering. As such, do not put hooks inside if statements or loops. If you do, you'll have insane bugs that involve `useState` returning the wrong state. If you see `useState` returning the wrong piece of state, this is likely what you did. Every hook must run every time in the same order. They should always be called at the top level of a component.

### useState

The call to `useState` below is called a hook.

```jsx
// in Order.jsx
import { useState } from "react";

// pizzaType and pizzaSize location
const [pizzaType, setPizzaType] = useState("pepperoni");
const [pizzaSize, setPizzaSize] = useState("medium");

// replace input
<select
  onChange={(e) => setPizzaType(e.target.value)}
  name="pizza-type"
  value={pizzaType}
>
  [â€¦]
</select>

// add to all the radio buttons
onChange={(e) => setPizzaSize(e.target.value)}
```

Notes:

- The argument given to `useState` is the default value. In our case, we could give it `""` as our default value to make the user have to select something first, but in our case we want to default to pepperoni pizza and medium size.
- `useState` returns to us an array with two things in it: the current value of that state and a function to update that state. We're using a feature of JavaScript called destructuring to get both of those things out of the array.
- We could have put an `onChange` handler on each of the radio buttons. However event bubbling works the same in React as it does in the normal DOM and we could put it directly on the `div` that encapsulates all the radio buttons and just have to do it once.
- The above is known as a **controlled form** in that we're using hooks to control each part of the form. In reality, it's better to leave these **uncontrolled** (aka don't set the value) and wrap the whole thing in a `form`, and listen for `submit` events and use that event to gather info off the form. If you need to do dynamic validation, react to a user typing a la typeahead, then a controlled input is perfect, otherwise stick to uncontrolled. Also what's new in React is called a "form action" that is considered unstable. In the future you will just add `<form action="blah">[...]</form>` and a form action will handle the entire form for you.

### useEffect

Effect here means side-effect. We have work on the render hotpath, and then "other background work" we want to happen that doesn't need to be on that path.

`useEffect` allows you to say do a render of this component first so the user can see something, then as soon as the render is done, then take care of these other tasks. Here we want the user to see our UI first then we want to make a request to the API so we can initialize a list of pizzas.

```jsx
useEffect(() => {
  fetchPizzaTypes();
  return () => clearTimeout(timeout); // optional return allows for effect cleanup work
}, []); // empty array here is the state comparison parameter - effectively this is a one-off effect
```

More complete example:

```jsx
const intl = Intl.NumberFormat("en-AU", {
  style: "currency",
  currency: "AUD",
});

export default function Order(): JSX.Element {
  const [pizzaList, setPizzaList] = useState<PizzaType[]>([]);
  const [pizzaType, setPizzaType] = useState("pepperoni");
  const [pizzaSize, setPizzaSize] = useState("M");
  const [loading, setLoading] = useState(true);

  let price, selectedPizza;

  if (!loading) {
    selectedPizza = pizzaList.find((pizza) => pizza.id === pizzaType);
  }

  async function fetchPizzaTypes() {
    await new Promise((resolve) => setTimeout(resolve, 3000)); // fake loading delay
    const pizzasResponse = await fetch("/api/pizzas");
    const pizzasJson = await pizzasResponse.json();
    setPizzaList(pizzasJson);
    setLoading(false);
  }

  useEffect(() => {
    fetchPizzaTypes();
  }, []);

  return (
    <div className="order">
      <h2>Create Order</h2>
      <form>

      ...

        <div className="order-pizza">
          {selectedPizza ? (
            <Pizza
              name={selectedPizza.name}
              description={selectedPizza.description}
              image={selectedPizza.image}
            />
          ) : (
            <div>Loading pizza...</div>
          )}
          <p>
            {selectedPizza
              ? intl.format(
                  selectedPizza.sizes[
                    pizzaSize as keyof typeof selectedPizza.sizes
                  ],
                )
              : "$0.00"}
          </p>
        </div>
      </form>
    </div>
  );
}
```

Notes:

- We put all the logic for fetching pizza types in an `async` function to make it more readable. You can't make the function provided to `useEffect` async.
- The `[]` at the end of the `useEffect` is where you declare your data dependencies. React wants to know when to run that effect again. You don't give it data dependencies, it assumes any time any hook changes, the effect needs to be re-scheduled and run again. This is bad because that would mean any time `setPizzaList` gets called it'd re-run render and all the hooks again. It'd run infinitely since `fetchPizzaTypes` calls `setPizzaList`.
- We're using a `loading` flag to only display data once it's ready. This is how you do conditional showing/hiding of components in React.
- The `key` portion is an interesting one. When React renders arrays of things, it doesn't know the difference between something is new and something is just being re-ordered in the array (think like changing the sorting of a results list, like price high-to-low and then priced low-to-high). Because of this, if you don't tell React how to handle those situations, it just tears it all down and re-renders everything anew. This can cause unnecessary slowness on devices. This is what `key` is for. Key tells React "this is a simple identifier of what this component is". If React sees you just moved a `key` to a different order, it will keep the component tree. So `key` here is to associate the `key` to something unique about that component. 99/100 this is a database ID of some variety.

### Custom Hooks

A custom hook is simply a function that calls other hooks, allowing you to encapsulate and reuse stateful logic across multiple components.

One thing that's pretty special about hooks is their composability i.e. using hooks to make other hooks. People tend to call these custom hooks. There are even people who go as far to say:

> "never make an API request in a component, always do it in a hook"

I don't know if I'm as hardcore as that but I see the logic in it. If you make a custom hook for those sorts of things they become individually testable and do a good job to separate your display of data and your logic to acquire data.

Okay, so we want to add a "Pizza of the Day" banner at the bottom of our page. This necessitates calling a special API to get the pizza of the day (which should change every day based on your computer's time). Let's first write the component that's going to use it.

```jsx
import { usePizzaOfTheDay } from "./PizzaOfTheDay";

const intl = new Intl.NumberFormat("en-AU", {
  style: "currency",
  currency: "AUD",
});

const PizzaOfTheDay = () => {
  const pizzaOfTheDay = usePizzaOfTheDay(); // USING THE CUSTOM HOOK ðŸŽ‰

  if (!pizzaOfTheDay) {
    return <div>Loading...</div>;
  }

  return (
    <div className="pizza-of-the-day">
      <h2>Pizza of the Day</h2>
      <div>
        <div className="pizza-of-the-day-info">
          <h3>{pizzaOfTheDay.name}</h3>
          <p>{pizzaOfTheDay.description}</p>
          <p className="pizza-of-the-day-price">
            From: <span>{intl.format(pizzaOfTheDay.sizes.S)}</span>
          </p>
        </div>
        <img
          className="pizza-of-the-day-image"
          src={pizzaOfTheDay.image}
          alt={pizzaOfTheDay.name}
        />
      </div>
    </div>
  );
};

export default PizzaOfTheDay;
```

Okay, let's go make the hook! Make a file called `usePizzaOfTheDay.ts` (in a React project its common to just use JSX/TSX for all "React-y" things):

```jsx
import { useState, useEffect } from "react";
import { PizzaType } from "./types";

export const usePizzaOfTheDay = () => {
  const [pizzaOfTheDay, setPizzaOfTheDay] =
    (useState < PizzaType) | (null > null);

  useEffect(() => {
    async function fetchPizzaOfTheDay() {
      const response = await fetch("/api/pizza-of-the-day");
      const data = await response.json();
      setPizzaOfTheDay(data);
    }

    fetchPizzaOfTheDay();
  }, []);

  return pizzaOfTheDay;
};
```

Notes:

- The cool part here is the `usePizzaOfTheDay()`. We now just get to rely on that this going to provide us with the pizza of the day from within the black box of the hook working.
- Custom hooks call other React hooks and follow the rules of hooks, such as being called in the same order and not being placed inside conditional statements or loops.
- What the sell to using custom hook? They enable reusable, composable logic that can be shared across different components, reducing code duplication and improving modularity.
- Custom hooks commonly use `useState` and `useEffect` to manage state and side effects within the hook's logic.
- Custom hooks usually start with the prefix 'use', such as `usePizzaOfTheDay`, which indicates that it is a hook and follows React's hook naming conventions.
- A handy debugging technique made especially for custom hooks is `useDebugValue(pizzaOfTheDay ? `${pizzaOfTheDay.name}` : "Loading...")`. Now open your React Dev Tools and inspect our `PizzaOfTheDay` component. You'll see our debug value there. This is helpful when you have lots of custom hooks and in particular lots of reused custom hooks that have differing values. It can help at a glance to discern which hook has which data inside of it.

### useContext

Usually, you will pass information from a parent component to a child component via props. But passing props can become verbose and inconvenient if you have to pass them through many components in the middle, or if many components in your app need the same information. Context lets the parent component make some information available to any component in the tree below itâ€”no matter how deepâ€”without passing it explicitly through props.

Let's make a cart indicator on the top right of the page. Create a file called `Header.tsx` and put this in there.

```jsx
export default function Header() {
  return (
    <nav>
      <h1 className="logo">Padre Gino's Pizza</h1>
      <div className="nav-cart">
        ðŸ›’<span className="nav-cart-number">5</span>
      </div>
    </nav>
  );
}
```

Use the new Header component in `App.tsx`:

```jsx
import Header from "./Header";

<Header />
...
```

The count is hard-coded to 5 right now. But we want that number in .nav-cart-number to reflect how many items we have in our cart. How would we do that? We could move all of cart and its hooks to `App.jsx` and pass it into both Header and Order. In an app this small, that could be the right choice. But let's look at another way to do it, context.

So let's make it work. Make a file called `contexts.tsx`. It's not a component so I tend to not capitalise it. The React docs do capitalise it. Up to you.

```jsx
import { createContext } from "react";
import type { Dispatch, SetStateAction } from "react";
import type { CartType } from "./types";

type CartContextType = [CartType[], Dispatch<SetStateAction<CartType[]>>];

const noop = (() => {}) as Dispatch<SetStateAction<CartType[]>>;

export const CartContext = createContext<CartContextType>([[], noop]);
```

The `[[], function () {}]` is that it's a React hook: an array where the first value is an array (like our cart is) and the second value is a function (the `setCart` function). Next wire it up in `App.tsx`:

```jsx
// at the top
import { StrictMode, useState } from "react"; // need useState
import { CartContext } from "./contexts";

// replace App
const App = () => {
  const cartHook = useState([]);
  return (
    <StrictMode>
      <CartContext.Provider value={cartHook}>
        <div>
          <Header />
          <Order />
          <PizzaOfTheDay />
        </div>
      </CartContext.Provider>
    </StrictMode>
  );
};
```

Let's go make `Order.tsx` work now:

```jsx
import { useState, useEffect, useContext } from "react"; // need useContext
import { CartContext } from "./contexts";

const [cart, setCart] = useContext(CartContext); // change cart hook to use context
```

Done. Lastly update the `Header` component to use context:

```jsx
import { useContext } from "react";
import { CartContext } from "./contexts";

// top of function
const [cart] = useContext(CartContext);

// replace span number
ðŸ›’<span className="nav-cart-number">{cart.length}</span>
```

## Forms and User Input

So now we want to be able to handle the user's cart and submitting our order. Let's go add what we need to `Order.tsx`:

```jsx
// add import
import Cart from "./Cart";

// add another hook
const [cart, setCart] = useState([]);

// replace <form>
<form
  onSubmit={(e) => {
    e.preventDefault();
    if (!selectedPizza) return;
    const price =
      selectedPizza.sizes[
        pizzaSize as keyof typeof selectedPizza.sizes
      ] ?? 0;
    setCart([...cart, { pizza: selectedPizza, size: pizzaSize, price }]);
  }}
>
  [â€¦]
</form>;

// just inside the last closing div
{
  loading ? <h2>LOADING â€¦</h2> : <Cart cart={cart} />;
}
```

Now lets make the cart component. Make a file called `Cart.tsx` and add:

```jsx
import { CartItemType } from "./types";

const intl = new Intl.NumberFormat("en-AU", {
  style: "currency",
  currency: "AUD",
});

export default function Cart({
  cart,
  checkout,
}: {
  cart: CartItemType[],
  checkout: () => void,
}): JSX.Element {
  let total = 0;
  for (let i = 0; i < cart.length; i++) {
    const current = cart[i];
    if (current) {
      total += current.pizza.sizes[current.size];
    }
  }
  return (
    <div className="cart">
      <h2>Cart</h2>
      <ul>
        {cart.map((item, index) => (
          <li key={index}>
            <span className="size">{item.size}</span> â€“
            <span className="type">{item.pizza.name}</span> â€“
            <span className="price">{item.price}</span>
          </li>
        ))}
      </ul>
      <p>Total: {intl.format(total)}</p>
      <button onClick={checkout}>Checkout</button>
    </div>
  );
}
```

### Push Cart to Server

So how do actually checkout on the server? Let's do that! We probably want to do it as the `Order` level. It already has the `Cart` and we can just leave the `Cart` as a dumb display component. We can just pass a function to call into the `Cart` component as a prop, and call it and run the function at the `Order` level. In the Order component add:

```jsx
// inside the render body
async function checkout() {
  setLoading(true);

  await fetch("/api/order", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      cart,
    }),
  });

  setCart([]);
  setLoading(false);
}

// pass the checkout function down to Cart as prop
<Cart checkout={checkout} cart={cart} />;
```

Now we can pass that checkout function in and whenever someone clicks inside the form, it will run the checkout function from the Order components. We're doing a simple loading animation, doing a fetch, and then clearing the status once we're all done. Not too bad!

## Passing Parameters to Event Handlers

It is common to want to pass some state along to the event handler, when its invoked.

One option is to create a wrapper function:

```js
handleIncrement = product => {
  console.log(product);
  this.setState({ count: this.state.count + 1 });
};

render() {
  return (
    <React.Fragment>
      <button
        onClick={() => this.handleIncrement({ id: 1 })}
        className="btn btn-secondary btn-sm"
      >
        Increment
      </button>
```

### Passing JSX as Props

Previously the `Counters` component, composed many `Counter` instances, like so, while defining a few `props`:

```jsx
<div>
  {this.state.counters.map((c) => (
    <Counter key={c.id} value={c.value} selected={true} />
  ))}
</div>
```

To make components even more useful, its possible to pass in inner JSX content, for example:

```jsx
<Counter key={c.id} value={c.value} selected={true}>
  <h2>semaphore</h2>
</Counter>
```

The `props` of the child component, exposes this `h2` via a list called `children`. To make use of the `props.children` property is easy:

```jsx
render() {
  return (
    <React.Fragment>
      {this.props.children}
      <span className={this.getBadgeClasses()}>{this.formatCount()}</span>
      ...
```

## Raising and Handling Events between Components

State management rule of thumb:

> The component that owns some state, should be responsible for mutating it.

A common scenario is for parent or outer components to define the state that is consumed by downstream components. Given the rule of thumb above, how should a downstream component go about modifying the original state?

One good option is the _observer pattern_, in which a child component raises an event, which can be handled by its parent component to react and respond to a state change.

For example, the `Counters` component defines several `Counter` components. A component can elect to delete itself by displaying a delete button to the user. If clicked, the `Counter` instance could raise an `onDelete` event. `Counters` could handle this event with `handleDelete()`.

In the `Counters` component:

- create event handler e.g. `handleDelete` responsible for mutating the original state that relates to the event. _important_ in React, you can't just mutate state and expect React to know about it, instead you must reassign the state using Reacts `setState` function (see below)
- pass this handler function downstream to `Counter` components as `props`

  class Counters extends Component {
  state = {
  counters: [
  { id: 1, value: 0 },
  { id: 2, value: 0 },
  { id: 3, value: 3 },
  { id: 4, value: 2 }
  ]
  };

      handleDelete = counterId => {
        console.log("Event handler called", counterId);
        const counters = this.state.counters.filter(c => c.id !== counterId);
        this.setState({ counters: counters });
      };

      render() {
        return (
          <div>
            {this.state.counters.map(c => (
              <Counter
                key={c.id}
                value={c.value}
                onDelete={this.handleDelete}
                selected={true}
              />
            ))}
          </div>

Using the _React Developer Tools_ browser extension, can drill down into `Counters` to an individual `Counter` instance, and check out its Props (right hand panel) - note the `onDelete` prop:

    Props
      onDelete: handleDelete()
      selected: true
      value: 0

In the `Counter` component, simply need to wire in the `onDelete` now available in `props` to the `onClick`:

    <button
      onClick={() => this.props.onDelete(this.props.id)}
      className="btn btn-danger btn-sm m-2"
    >

## Resources

- [Complete Intro to React v9 (2024 refresh) by Brian Holt](https://react-v9.holt.courses/)
- [v8 of the course](https://react-v8.holt.courses/) - for `react-router`
- [citr-v9-project](https://github.com/btholt/citr-v9-project)
- Keep render paths within components as lean as possible, as they are often hot paths being run many times. This is the most common cause of CLS (Cumulative Layout Shift) quantifies the amount of unexpected layout shifts that occur during the lifespan of a web page.
