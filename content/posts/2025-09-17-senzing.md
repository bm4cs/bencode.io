---
layout: post
draft: true
title: "Senzing Entity Resolution Primer"
slug: "senzing"
date: "2025-09-19 09:35:00+1000"
lastmod: "2025-09-19 09:35:00+1000"
comments: false
categories:
  - entityresolution
  - data
  - ER
---

- [Context](#context)
  - [Record vs Entity vs Relationship](#record-vs-entity-vs-relationship)
  - [Data Quality Issues ER Addresses](#data-quality-issues-er-addresses)
- [Senzing](#senzing)
  - [Repository](#repository)
  - [Key Senzing Attributes](#key-senzing-attributes)
  - [Resolution Concepts](#resolution-concepts)
    - [Candidates](#candidates)
    - [Features](#features)
    - [Feature Scores](#feature-scores)
    - [Match Levels](#match-levels)
    - [Resolution Rules](#resolution-rules)
- [.NET SDK](#net-sdk)
  - [Primary Interfaces](#primary-interfaces)
  - [Common Data Structures](#common-data-structures)
  - [Typical Implementation Flow](#typical-implementation-flow)
  - [Best Practices](#best-practices)
    - [Performance Optimization](#performance-optimization)
    - [Error Handling](#error-handling)
    - [Configuration Management](#configuration-management)
  - [Troubleshooting Quick Reference](#troubleshooting-quick-reference)
    - [Common Issues](#common-issues)
    - [Diagnostic Tools](#diagnostic-tools)
- [Senzing Setup](#senzing-setup)
  - [Environment](#environment)
  - [PostgreSQL](#postgresql)
  - [Provision DB schema (init-database)](#provision-db-schema-init-database)
  - [SDK Tools (senzingsdk-tools)](#sdk-tools-senzingsdk-tools)
    - [sz\_configtool](#sz_configtool)
      - [features](#features-1)
      - [principles](#principles)
  - [API (senzing-api-server)](#api-senzing-api-server)
- [Entity Resolutions Fundamentals](#entity-resolutions-fundamentals)
  - [Unstable Entity IDs](#unstable-entity-ids)

## Context

The process of identifying and linking records that refer to the same real-world entity across different data sources, even when the records contain variations, errors, or incomplete information.

- **Entity-Centric Learning**: A process where resolved entities are treated holistically, enabling the system to learn from every name and address variation
- **Sequence Neutrality**: The ability to reevaluate and improve prior ER decisions regardless of the order data is loaded
- **Auto-Generics Detection**: The ability to detect and handle widely used erroneous data during real-time ER
- **Disclosed Relationships**: Known connections between entities based on factual information
- **Derived Relationships**: Undisclosed or hidden connections between entities detected during ER
- **Find Path**: The ability to explore and reveal connections between distant entities in the entity graph
- **Privacy by Design (PbD)**: An engineering approach that considers privacy throughout the entire development process

### Record vs Entity vs Relationship

- **Record**: A single data entry from a source system (customer record, transaction, etc.)
- **Entity**: A resolved real-world object that may be represented by multiple records
- **Relationship**: Connections between entities (family members, business associates, etc.)

### Data Quality Issues ER Addresses

- **Duplicates**: Multiple records for the same entity
- **Variants**: Name variations (Bob/Robert, Inc/Incorporated)
- **Typos**: Misspellings and data entry errors
- **Incomplete Data**: Missing fields across records
- **Inconsistent Formats**: Different date/phone/address formats

## Senzing

Specifically I'm interested in Senzing aka `G2`, `G2` being the OG code name of what Senzing is today, which began as a 2009 IBM skunkworks project.

Senzing configuration is concerned with the following concepts:

- Data sources
- Entity types
- Features and attributes
- Resolution rules
- Thresholds

Examples of entity types:

- **PERSON**: Individuals
- **ORGANIZATION**: Companies, agencies
- **VESSEL**: Ships, aircraft
- **Custom Types**: Domain-specific entities

### Repository

Storage layer containing:

- **Resolved Entities**: Final entity representations
- **Records**: Original input records
- **Relationships**: Entity connections
- **Features**: Extracted and standardized data

These logical layers map to a data store:

- **Master List**: A curated collection of entities (e.g., customer list, employee database) that may contain duplicates and is used for entity resolution
- **Transaction Data**: Event-based records containing identifying information about entities, used to connect with master records and watchlists
- **Watchlist**: A collection of entities you want to avoid due to potential risks (e.g., fraudsters, sanctioned individuals)
- **Reference List**: Supplemental data used to enrich entity understanding (e.g., demographics, historical addresses)

### Key Senzing Attributes

- `DATA_SOURCE`: A required string attribute identifying the source of the record (max 25 characters)
- `RECORD_ID`: A unique identifier within a data source, strongly recommended for updates and maintenance
- `RECORD_TYPE`: Specifies the type of entity (e.g. `PERSON`, `ORGANIZATION`) to prevent inappropriate resolutions
- `NAME_TYPE`: Classifies names as `PRIMARY` or `ALIAS`, used for entity resolution

### Resolution Concepts

#### Candidates

Records that potentially match during resolution process.

#### Features

Standardized, comparable attributes extracted from raw data:

- **NAME_FULL**: Standardized full names
- **ADDR_FULL**: Standardized addresses
- **PHONE**: Standardized phone numbers
- **EMAIL**: Email addresses
- **DOB**: Date of birth
- **SSN**: Social Security Numbers

#### Feature Scores

Numerical similarity scores between features (0-100):

- **Exact Match**: 100
- **Close Match**: 80-99
- **Likely Match**: 60-79
- **Possible Match**: 40-59

#### Match Levels

Senzing's confidence levels for entity relationships:

1. **Match (Level 1)**: Very high confidence same entity
2. **Possible Match (Level 2)**: Likely same entity, review recommended
3. **Possible Relation (Level 3)**: Likely related entities
4. **Name Only Match (Level 4)**: Shared name, different entities

#### Resolution Rules

Logic determining when records should resolve:

- **Principle**: Core matching logic (exact SSN match)
- **Rule**: Specific matching combinations
- **Threshold**: Minimum scores required

## .NET SDK

### Primary Interfaces

```csharp
// Core engine interface
public interface G2Engine
{
    // Add records
    int AddRecord(string dataSourceCode, string recordId, string jsonData);

    // Get entity details
    string GetEntity(long entityId);

    // Search for entities
    string SearchByAttributes(string jsonData);

    // Get relationships
    string FindNetworkByEntityId(long entityId, int maxDegrees);
}

// Configuration management
public interface G2Config
{
    string Save();
    int Load(string configStr);
    int AddDataSource(string dataSourceCode);
}

// Diagnostic interface
public interface G2Diagnostic
{
    string GetDataSourceCounts();
    string GetEntitySizeBreakdown(int minimumEntitySize);
}
```

### Common Data Structures

```csharp
// Input record format
var recordJson = @"{
    'NAME_FULL': 'John Smith',
    'ADDR_FULL': '123 Main St, Anytown, NY 12345',
    'PHONE': '555-123-4567',
    'EMAIL': 'john.smith@email.com',
    'DOB': '1980-05-15'
}";

// Entity response structure
{
    "ENTITY_ID": 12345,
    "RECORDS": [...],
    "FEATURES": {...},
    "RELATED_ENTITIES": [...]
}
```


### Typical Implementation Flow

1. **Initialize Engine**

   ```csharp
   var engine = new G2EngineImpl();
   engine.Init("MyApp", configJson, verboseLogging);
   ```

2. **Load Configuration**

   ```csharp
   var config = new G2ConfigImpl();
   var configId = config.Create();
   engine.ReplaceConfig(configId);
   ```

3. **Add Data Sources**

   ```csharp
   config.AddDataSource("CUSTOMER_DB");
   config.AddDataSource("CRM_SYSTEM");
   ```

4. **Process Records**

   ```csharp
   engine.AddRecord("CUSTOMER_DB", "CUST001", recordJson);
   ```

5. **Query Results**
   ```csharp
   var entity = engine.GetEntity(entityId);
   var matches = engine.SearchByAttributes(searchJson);
   ```

### Best Practices

#### Performance Optimization

- Use bulk loading for large datasets
- Implement proper threading for concurrent access
- Monitor memory usage during processing
- Use streaming for large result sets

#### Error Handling

```csharp
try
{
    var result = engine.AddRecord(dataSource, recordId, jsonData);
    if (result != 0)
    {
        var error = engine.GetLastException();
        // Handle error appropriately
    }
}
catch (G2Exception ex)
{
    // Handle Senzing-specific exceptions
}
```

#### Configuration Management

- Version control configuration changes
- Test configuration in development environment
- Use staged deployments for configuration updates
- Monitor resolution quality after changes

### Troubleshooting Quick Reference

#### Common Issues

- **Poor Match Quality**: Review feature configuration and thresholds
- **Performance Issues**: Check threading, memory allocation, database tuning
- **Configuration Errors**: Validate JSON syntax and required fields
- **Memory Leaks**: Ensure proper disposal of engine instances

#### Diagnostic Tools

```csharp
// Get processing statistics
var stats = diagnostic.GetDataSourceCounts();

// Analyze entity size distribution
var breakdown = diagnostic.GetEntitySizeBreakdown(2);

// Review feature utilization
var features = engine.GetFeatureStatistics();
```

This primer covers the essential concepts and terminology you'll encounter when building your entity resolution system with Senzing's .NET SDK. Focus on understanding the resolution workflow and key configuration concepts as you begin implementation.

## Senzing Setup

### Environment

Create an `.env` next to the compose YAML:

```ini
DB_NAME=G2
DB_USER=senzing_user
DB_PASS=senzing_pass
DB_HOST=172.21.32.110
DB_PORT=5432
```

### PostgreSQL

Create a `docker-compose.yml`:

```yaml
version: "3.8"
services:
  postgres:
    image: postgres:latest
    container_name: senzing_postgres
    environment:
      - POSTGRES_DB=${DB_NAME}
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASS}
    network_mode: "host"
    ports:
      - "5432:5432"
    volumes:
      - ./data/postgres:/var/lib/postgresql/data
      - ./pg_hba.conf:/var/lib/postgresql/data/pg_hba.conf
    restart: unless-stopped
    # command: ["postgres", "-c", "hba_file=/var/lib/postgresql/data/pg_hba.conf"]
```

Then boot it up `docker compose up`

### Provision DB schema (init-database)

```sh
export SENZING_ENGINE_CONFIGURATION_JSON='{
 "PIPELINE" : {
  "CONFIGPATH" : "/etc/opt/senzing",
  "RESOURCEPATH" : "/opt/senzing/er/resources",
  "SUPPORTPATH" : "/opt/senzing/data"
 },
 "SQL" : {
  "CONNECTION" : "postgresql://senzing_user:senzing_pass@172.21.32.110:5432:G2?sslmode=disable"
 }
}'

docker run --network=host --rm --env SENZING_ENGINE_CONFIGURATION_JSON senzing/init-database --install-senzing-er-configuration
```

Tip: Make sure that connection string uses non-standard style colon delimiters as per [docs](https://senzing.com/docs/quickstart/quickstart_docker/).

This will create the following tables in the `public` schema:

```
dsrc_record
lib_feat
obs_ent
res_ent
res_ent_okey
res_feat_ekey
res_feat_stat
res_rel_ekey
res_relate
sys_cfg
sys_codes_used
sys_eval_queue
sys_hw_check
sys_sequence
sys_status
sys_vars
```

### SDK Tools (senzingsdk-tools)

https://senzing.com/docs/quickstart/quickstart_docker/

```yaml
version: "3.8"
services:
  postgres:
    image: postgres:latest
    container_name: senzing_postgres
    environment:
      - POSTGRES_DB=${DB_NAME}
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASS}
    network_mode: "host"
    ports:
      - "5432:5432"
    volumes:
      - ./data/postgres:/var/lib/postgresql/data
      - ./pg_hba.conf:/var/lib/postgresql/data/pg_hba.conf
    restart: unless-stopped
    command: ["postgres", "-c", "hba_file=/var/lib/postgresql/data/pg_hba.conf"]

  senzing-tools:
    image: senzing/senzingsdk-tools
    container_name: senzing_tools
    network_mode: "host"
    environment:
      SENZING_ENGINE_CONFIGURATION_JSON: |
        {
          "PIPELINE": {
            "CONFIGPATH": "/etc/opt/senzing",
            "RESOURCEPATH": "/opt/senzing/er/resources",
            "SUPPORTPATH": "/opt/senzing/data"
          },
          "SQL": {
            "CONNECTION": "postgresql://${DB_USER}:${DB_PASS}@${DB_HOST}:${DB_PORT}:${DB_NAME}?sslmode=disable"
          }
        }
    volumes:
      - ./data/senzing:/data
    depends_on:
      - postgres
    restart: unless-stopped
    command: tail -f /dev/null # keep container running
```

TTY into the senzing_tools containers:

```sh
docker exec -it senzing_tools bash
cd /opt/senzing/er/bin
```

Tools available:

- `sz_audit`: Tool for system audits and analyzing entity resolution processes
- `sz_json_analyzer`: Analyzes and validates JSON data structures within the Senzing environment
- `sz_snapshot`: Creates snapshots of the current project state for backup and version control purposes
- `sz_command`: Processes and executes various Senzing-related commands and operations
- [`sz_explorer`](https://senzing.com/docs/tutorials/eda/eda_basic_exploration/): Interactive exploratory data analysis tool for examining resolved entities and their relationships
- `sz_configtool`: Utility for managing and configuring data sources

#### sz_configtool

This utility allows you to configure a Senzing instance.

Senzing compares records within and across data sources. Records consist of features and features have attributes. For instance, the `NAME` feature has attributes such as `NAME_FIRST` and `NAME_LAST` for a person and `NAME_ORG` for an organization.

Features are standardised and expressed in various ways to create candidate keys, and when candidates are found all of their features are compared to the features of the incoming record to see how close they actually are.

Finally, a set of rules or "principles" are applied to the feature scores of each candidate to see if the incoming record should resolve to an existing entity or become a new one. In either case, the rules are also used to create relationships between entities.

- `help basic`: for commonly used commands
- `help features`: to be used only with the guidance of Senzing support
- `help principles`: to be used only with the guidance of Senzing support
- `help all`: to show all configuration commands

To understand more about configuring Senzing:

- [ER Processes](https://senzing.com/wp-content/uploads/Entity-Resolution-Processes-021320.pdf)
- [Principle Based ER](https://senzing.com/wp-content/uploads/Principle-Based-Entity-Resolution-092519.pdf)
- [Entity Specification](https://senzing.zendesk.com/hc/en-us/articles/231925448-Generic-Entity-Specification-JSON-CSV-Mapping)

##### features

**listFeatures**:

Note the `standardize` functions, such as `PARSE_PHONE`, for normalizing data:

```
┌────┬────────────────────────────┬────────────────┬──────────┬───────────┬────────────┬────────────────────┬────────────────┬──────────────────────────┬──────────┬─────────┬
│ id │ feature                    │ class          │ behavior │ anonymize │ candidates │ standardize        │ expression     │ comparison               │ matchKey │ version │
├────┼────────────────────────────┼────────────────┼──────────┼───────────┼────────────┼────────────────────┼────────────────┼──────────────────────────┼──────────┼─────────┼
│ 1  │ NAME                       │ NAME           │ NAME     │ No        │ No         │ PARSE_NAME         │ NAME_HASHER    │ GNR_COMP                 │ Yes      │ 2       │
├────┼────────────────────────────┼────────────────┼──────────┼───────────┼────────────┼────────────────────┼────────────────┼──────────────────────────┼──────────┼─────────┼
│ 2  │ DOB                        │ BIO_DATE       │ FMES     │ No        │ Yes        │ PARSE_DOB          │                │ DOB_COMP                 │ Yes      │ 2       │
├────┼────────────────────────────┼────────────────┼──────────┼───────────┼────────────┼────────────────────┼────────────────┼──────────────────────────┼──────────┼─────────┼
│ 3  │ DOD                        │ BIO_DATE       │ FMES     │ No        │ Yes        │ PARSE_DOB          │                │ DOB_COMP                 │ Yes      │ 2       │
├────┼────────────────────────────┼────────────────┼──────────┼───────────┼────────────┼────────────────────┼────────────────┼──────────────────────────┼──────────┼─────────┼
│ 4  │ GENDER                     │ BIO_FEATURE    │ FVME     │ No        │ No         │                    │                │ EXACT_DOMAIN_COMP        │ Denial   │ 1       │
├────┼────────────────────────────┼────────────────┼──────────┼───────────┼────────────┼────────────────────┼────────────────┼──────────────────────────┼──────────┼─────────┼
│ 5  │ ADDRESS                    │ POSTAL_ADDRESS │ FF       │ No        │ No         │ PARSE_ADDR         │ ADDR_HASHER    │ ADDR_COMP                │ Yes      │ 4       │
├────┼────────────────────────────┼────────────────┼──────────┼───────────┼────────────┼────────────────────┼────────────────┼──────────────────────────┼──────────┼─────────┼
│ 6  │ PHONE                      │ PHONE          │ FF       │ No        │ No         │ PARSE_PHONE        │ PHONE_HASHER   │ PHONE_COMP               │ Yes      │ 1       │
├────┼────────────────────────────┼────────────────┼──────────┼───────────┼────────────┼────────────────────┼────────────────┼──────────────────────────┼──────────┼─────────┼
```

##### principles

Before the principles are applied, the features and expressions created for an incoming record are used to find candidates. An example of an expression is name and DOB and there is an expression call on the feature "name" to automatically create it if both a name and DOB are present on the incoming record. Features and expressions used for candidates are also referred to as candidate builders or candidate keys.

- `listFeatures`: to see what features are used for candidates
- `setFeature`: to toggle whether or not a feature is used for candidates
- `listExpressionCalls`: to see what expressions are currently being created
- `addToNamehash`: to add an element from another feature to the list of composite name keys
- `addExpressionCall`: to add a new expression call, aka candidate key
- `listGenericThresholds`: to see when candidate keys will become generic and are no longer used to find candidates
- `setGenericThreshold`: to change when features with certain behaviors become generic

Once the candidate matches have been found, scoring and rule evaluation takes place. Scores are rolled up by behavior. For instance, both addresses and phones have the behavior `FF` (Frequency Few). If they both score above their scoring functions close threshold, there would be two `CLOSE_FF`s (a fragment) which can be used in a rule such as `NAME+CLOSE_FF`.

Commands that help with configuring principles (rules) and scoring:

- `listRules`: these are the principles that are applied top down
- `listFragments`: rules are combinations of fragments like close_name or same_name
- `listFunctions`: the comparison functions show you what is considered same, close, likely, etc.
- `setRule`: to change whether an existing rule resolves or relates

### API (senzing-api-server)

```yaml
version: "3.8"
services:
  postgres:
    image: postgres:latest
    container_name: senzing_postgres
    environment:
      - POSTGRES_DB=${DB_NAME}
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASS}
    network_mode: "host"
    ports:
      - "${DB_PORT}:${DB_PORT}"
    volumes:
      - ./data/postgres:/var/lib/postgresql/data
      - ./pg_hba.conf:/var/lib/postgresql/data/pg_hba.conf
    restart: unless-stopped
    # command: ["postgres", "-c", "hba_file=/var/lib/postgresql/data/pg_hba.conf"]

  senzing-api-server:
    environment:
      SENZING_API_SERVER_ALLOWED_ORIGINS: '*'
      SENZING_API_SERVER_ENABLE_ADMIN: 'true'
      SENZING_ENGINE_CONFIGURATION_JSON: >-
        {
          "PIPELINE": {
            "CONFIGPATH": "/etc/opt/senzing",
            "LICENSESTRINGBASE64": "${SENZING_LICENSE_BASE64_ENCODED}",
            "RESOURCEPATH": "/opt/senzing/g2/resources",
            "SUPPORTPATH": "/opt/senzing/data"
          },
          "SQL": {
            "BACKEND": "SQL",
            "CONNECTION": "postgresql://${DB_USER}:${DB_PASS}@${DB_HOST}:${DB_PORT}:${DB_NAME}?sslmode=disable"
          }
        }
    image: senzing/senzing-api-server:${SENZING_DOCKER_IMAGE_VERSION_SENZING_API_SERVER:-latest}
    networks:
      - senzing
    ports:
      - 8250:8250
    environment:
      # Database connection parameters
      - DATABASE_PROTOCOL=postgresql
      - DATABASE_USERNAME=${DB_USER}
      - DATABASE_PASSWORD=${DB_PASS}
      - DATABASE_HOST=${DB_HOST}
      - DATABASE_PORT=${DB_PORT}
      - DATABASE_DATABASE=${DB_NAME}
      - SENZING_DATABASE_URL="${DATABASE_PROTOCOL}://${DATABASE_USERNAME}:${DATABASE_PASSWORD}@${DATABASE_HOST}:${DATABASE_PORT}/${DATABASE_NAME}?sslmode=disable"
      - SENZING_API_SERVER_BIND_ADDR=all
      - SENZING_API_SERVER_PORT=8250
      - SENZING_API_SERVER_SECURE_PORT=8263
      - SENZING_API_SERVER_CONCURRENCY=10
      - SENZING_API_SERVER_ALLOWED_ORIGINS=*
      - SENZING_API_SERVER_KEY_STORE=/certs/server-store.p12
      - SENZING_API_SERVER_KEY_STORE_PASSWORD=your_password
```

## Entity Resolutions Fundamentals

<https://senzing.zendesk.com/hc/en-us/articles/4415858978067-How-does-an-Entity-ID-behave>

### Unstable Entity IDs
