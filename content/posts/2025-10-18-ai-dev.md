---
layout: post
draft: true
title: "AI Dev Setup"
slug: "aidev"
date: "2025-10-18 15:29:00+1000"
lastmod: "2025-10-18 15:29:00+1000"
comments: false
categories:
  - claude
  - cursor
  - dev
  - mcp
  - ai
---

A place to document how I use AI to assist the development of software. To increase its chances of enduring time, I'll focus on age old approaches that have worked for decades: thinking and planning, good source control discipline, testing, linting code quality, etc.

- [Context Is King](#context-is-king)
  - [Token Sizing Guidelines (Pebble → Boulder)](#token-sizing-guidelines-pebble--boulder)
  - [Caching Codebase Knowledge](#caching-codebase-knowledge)
  - [1. `CLAUDE.md` Files (Persistent Memory)](#1-claudemd-files-persistent-memory)
  - [2. API-Level Prompt Caching](#2-api-level-prompt-caching)
  - [Best Practice Workflow](#best-practice-workflow)
- [Claude](#claude)
  - [Claude Code Context Management Cheat Sheet](#claude-code-context-management-cheat-sheet)
    - [Lean AF Claude Code Workflow](#lean-af-claude-code-workflow)
  - [Subagents](#subagents)
  - [Skills](#skills)
  - [Plugins](#plugins)
  - [Hooks](#hooks)
  - [Teleport Sessions](#teleport-sessions)
- [Context Window Management](#context-window-management)
  - [vibe-rules](#vibe-rules)

## Context Is King

Managing the context window for your model is **the most** benefitial you can do as the human-in-the-loop.

### Token Sizing Guidelines (Pebble → Boulder)

| Size         | Tokens   | What fits                                                                           |
| ------------ | -------- | ----------------------------------------------------------------------------------- |
| **Pebble**   | <5K      | A single focused task, small file edits, quick questions                            |
| **Stone**    | 5-20K    | Baseline session startup in a typical repo, a `CLAUDE.md` file + a few files loaded |
| **Rock**     | 20-50K   | A moderate coding session, several files + conversation history                     |
| **Boulder**  | 50-150K  | Complex multi-file refactors, full feature implementation                           |
| **Mountain** | 150-200K | Near context limit on standard plans—performance often degrades past ~80%           |

**Practical benchmarks from users:**

- A fresh session in a monorepo costs a baseline ~20k tokens (10%) with the remaining 180k for making your change.
- The autocompact buffer can consume 45k tokens—that's 22.5% of your context window gone before writing a single line of code.
- Avoid using the final 20% of your context window for complex tasks, as performance degrades significantly when approaching limits.

### Caching Codebase Knowledge

### 1. `CLAUDE.md` Files (Persistent Memory)

This is the primary way to persist codebase knowledge across sessions:

- All memory files are automatically loaded into Claude Code's context when launched.
- Keep your `CLAUDE.md` under 5K tokens with project patterns, architecture decisions, coding standards, and key relationships
- `CLAUDE.md` files capture your project's patterns and standards, custom commands encode repetitive workflows.

### 2. API-Level Prompt Caching

If you're using the API directly or via Amazon Bedrock:

- Claude Code automatically enables prompt caching to optimize performance and costs.
- The cache has a "5-minute lifetime, refreshed each time the cached content is used."
- Cache reads are 90% cheaper than standard input tokens
- There's also a 1-hour cache option at additional cost

### Best Practice Workflow

Use `CLAUDE.md` files for persistent memory instead of repeating instructions. Write design docs and task lists to markdown files that Claude can reference.

The `CLAUDE.md` approach is the practical "cache" for codebase knowledge—it persists indefinitely and loads automatically every session, unlike API-level caching which expires.

## Claude

- [Repomix](https://repomix.com/): Packages your entire codebase into a single AI-friendly file `repomix-output.xml`
- [vibe-rules](https://www.npmjs.com/package/vibe-rules) CLI tool for managing and sharing AI rules (prompts, configurations) across different editors and tools
- [Extended Thinking Mode (Anthropic)](https://www.anthropic.com/news/visible-extended-thinking) - Documentation on Claude's thinking capabilities
- [Crystal](https://github.com/stravu/crystal): A tool for managing Git worktrees for Claude Code

- [Claude Code Plugins](https://www.anthropic.com/news/claude-code-plugins)
- [Awesome Claude Prompts](https://github.com/langgptai/awesome-claude-prompts)
- [Awesome Claude Code](https://github.com/hesreallyhim/awesome-claude-code?tab=readme-ov-file)
- [Claude Code Sub-Agents Collection](https://github.com/augmnt/agents)

- [Jesse Vincent's `CLAUDE.md`](https://raw.githubusercontent.com/obra/dotfiles/6e088092406cf1e3cc78d146a5247e934912f6f8/.claude/`CLAUDE.md`)

- [Seth Hobsons Claude Code Plugins: Orchestration and Automation](https://github.com/wshobson/agents)
- [Live LLM Token Counter](#) VSCode extension for calculating token cost/count of active file in the status bar

### Claude Code Context Management Cheat Sheet

It's key to manage context window "baggage" to get the most out of Claude Code.

- `/context`: Lists every single file currently loaded into the context window.
- `/usage`: Shows current session token usage, cost incurred, and how close you are to the limit
- `/compact`: Takes your conversation history (the back-and-forth chat) and summarises it. When the tool tells your "History is getting long." It converts 50 messages into a short summary to free up space.
- `/clear`: Wipes everything. It forgets the conversation history and unloads all files. It keeps your project configuration (`CLAUDE.md`), but clears the active session. **This is your best friend.** Run this between every major task. Treat it like "closing the tab" and starting fresh.
- `/memory`: Opens your `CLAUDE.md` file (the 530k char monster) for editing. Run this regularly and keep it as lean as possible (under 100 lines).

#### Lean AF Claude Code Workflow

To avoid hitting limits, adopt this loop:

1.  **Start:** `/reset` (clean house).
2.  **Load:** `/add src/components/MyComponent.tsx` (only the file you need).
3.  **Work:** Ask Claude to refactor.
4.  **Verify:** Check the code.
5.  **Finish:** `/remove src/components/MyComponent.tsx` (or just `/reset` again).
6.  **Repeat.**

### Subagents

[Subagents](https://docs.claude.com/en/docs/claude-code/sub-agents) are specialized AI assistants in Claude Code that focus on specific domains of software engineering. They provide expert-level guidance, automate complex tasks, and coordinate with other agents to deliver comprehensive solutions.

Importantly each subagent operates in its own context, preventing pollution of the main conversation, helping to keep it focused on high-level objectives.

### Skills

TODO

### Plugins

TODO

### Hooks

TODO

### Teleport Sessions

TODO

## Context Window Management

### vibe-rules

Much of the web dev eco-system provides great LLM context support. Such as TanStack Router using [vibe-rules](https://www.npmjs.com/package/vibe-rules).

In the evolving AI landscape, prompts and context are becoming increasingly crucial components of development workflows. Just like code libraries, reusable AI rules and prompts are emerging as shareable assets.

We anticipate more NPM packages will begin exporting standardized AI configurations, often via a `llms` entry point (e.g., `my-package/llms`). vibe-rules embraces this trend with the install command.

```
npm i -g vibe-rules
vibe-rules install claude-code
```

vibe-rules cheat sheet:

```sh
# Save from a file (e.g., .mdc, .md, or plain text)
vibe-rules save my-rule-name -f ./path/to/rule-content.md

# See all the rules you've saved to the common local store
vibe-rules list

# Load 'my-rule-name' for Claude Code IDE globally (updates ~/.claude/`CLAUDE.md`)
vibe-rules load my-rule-name claude-code --global
# Alias: vibe-rules add my-rule-name claude-code -g


# Most common: Install rules from ALL dependencies/devDependencies for claude-code
# Scans package.json, finds packages with 'llms' export, applies rules.
vibe-rules install claude-code

# Install rules from a specific package for claude-code
# (Assumes 'my-rule-package' is in node_modules)
vibe-rules install claude-code my-rule-package

# Install rules from a specific package into a custom target dir for Roo/Cline
vibe-rules install roo my-rule-package -t ./custom-ruleset/

# Install rules into the project's unified .rules file
vibe-rules install unified my-awesome-prompts
```

Several editors are supported, here's how claude code integration works:

- Appends/updates rules within XML-like tagged blocks in a `<!-- vibe-rules Integration -->` section in `./`CLAUDE.md`` (local) or `~/.claude/`CLAUDE.md`` (global).
- Each rule is encapsulated in tags like `<rule-name>...</rule-name>` within the single markdown file.
- Supports metadata formatting for `alwaysApply` and `globs` configurations.
