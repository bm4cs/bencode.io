---
layout: post
title: "Rust"
draft: false
slug: "rust"
date: "2021-12-11 22:21:47+11:00"
lastmod: "2022-02-12 20:34:44+11:00"
comments: false
categories:
  - rust
tags:
  - rust
  - dev
  - rustlang
---

Please refer to Don Bright's original [rust-lang-cheat-sheet](https://github.com/donbright/rust-lang-cheat-sheet) which I based much of this content off, as I work through [The Book](https://doc.rust-lang.org/book/).

## Rust in a nutshell

- Syntax similar to C
- Ownership of memory enforced at compile time
- Statically linked
- Functional-ish, generic-ish, not so objecty
- Control flow using patterns, `match` keyword
- Packages: 'cargo' command, <https://crates.io>
- Testing: cargo test, `#[test]`
- Concurrency: ownership, mutability, channels, mutex, crossbeam + Rayon packages
- Auto formatter: `rustfmt filename.rs`
- Compiler engine: LLVM
- Raw pointers, low level: `unsafe{}` keyword

## Documentation

- `rustup doc` for offline docs!
- [doc.rust-lang.org](https://doc.rust-lang.org/std/) standard library, primitive types, standard macros
- [docs.rs](https://docs.rs/) for package documentation

## Toolchain

```bash
$ rustup.sh               # install rust, see rust-lang.org for details
$ cargo new myproj        # start new executable project
$ cargo new --bin myproj  # as above
$ cargo new --lib myproj  # start new library project
$ cd myproj               # cd into the new directory
$ ls -lR                  # list our skeleton of files
src/main.rs               # main.rs, has main() entry point
Cargo.toml                # Cargo.toml defines packaging
$ $EDITOR Cargo.toml      # add dependencies and other details
$ cargo build             # downloads dependencies + builds main.rs
$ cargo build --release   # release build
$ cargo check             # make sure code compiles, without binary outputs
$ cargo update            # ignore Cargo.lock and figure out latest versions
$ cargo run               # runs program created from main.rs
$ cargo doc --open        # local web based doc
$ cargo test              # runs tests (in parallel by default)
$ cargo test -- --test-threads=1  # run tests one at a time
$ cargo test -- --nocapture       # run tests, show output
$ cargo run --example fundemo -- --argtodemo # run example with argument
```

## Mutability basic

```rust
let x = false;           // all variable bindings are immutable by default
x = true;                // compile error: can't change an immutable binding
let mut p = false;       // "mut" designates a binding as mutable
p = true;                // ok, mutable binding can change;
```

## Types and variables

```rust
let x: bool = false; // let keyword
let k = false;       // rustc can determine some types, this is idiomatic rust
let y: char = '上';  // all chars are 4 bytes
let 上 = 5;          // error. identifiers must be ASCII characters
let a: i8 = -2;      // 8 bit signed integers, also i16, i32, i64
let b: u8 = 200;     // 8 bit unsigned integers, also u16, u32, u64
let n: f32 = 0.45;   // 32 bit float (automatcally converted+rounded from decimal to binary)
let n = 42.01f64;    // 64 bit float literal of the number 42.01 (approximately)
let r: [u8;3] = [3,4,5];          // array of 3 int, cannot grow
let s = [0;500];                  // array of 500 integers, each initialized to 0
let s = &r[0..2];                 // slice of array, s==&[3,4]
let s = &r[0..2][0];              // index into slice, s==3
let mut u:Vec<u8> = Vec::new();   // create empty vector of unsigned 8 bit int, can grow
let mut v = vec![3,4,5];          // initialize mutable vector using vec! macro
let w = vec![1,12,13];            // vectors can be immutable too
u.push( 2 );                      // append item to vector
u.pop();                      // vectors can return+remove last input (like a stack)
v.contains(&3);               // true if vector contains value
v.remove(1);                  // remove the nth item from a vector...
v.append(u);                  // append v with u (u becomes empty ([]), both mutable)
v.extend(w);                  // extend v with w (v owns w, w can be immutable)
v.resize(200,0);              // make vector have 200 elements, set them to 0
let x = &w[1..];              // get a slice of a vector (a view into it's elements)
print("{:?}",x);              // [12,13];
let vs = v.len();             // length of vector
let (p,d,q) = (4,5,6);        // tuple() can assign multiple variables at once
print("{}",p);                // you can use them alone after tuple assignment
let m = (4,5,"a");            // tuples can have multiple different types as elements
let (a,b) = m.0, m.2;         // tuple indexing with .0, .1, .2, etc
let (a,b) = m.p, m.q;         // error, cannot index into a tuple using a variable
let (x, y, z) = m;            // tuple destructuring into individual variables

let s = String::from("上善若水");  // String
let s2 = "水善利萬物而不爭";       // string literal, type is &str
let s3 = format!("{}{}",s2,s3);    // concatenate strings
for i in "말 한마디에 천냥 빚을 갚는다".split(" ") {print!("{}",i);} // split string
let s4 = s.get(0..2);              // Substring using indexes
let i4 = s.find('水').unwrap_or(-1); // find index of character (not a byte offset)
let hellomsg = r###"               // Multi-line with embedded quotes
 "Hello" in Chinese is 你好 ('Ni Hao')
 "Hello" in Hindi is नमस्ते ('Namaste')
"###;

usize, isize              // this is the pointer size. used in loops, vector length, etc

const BILBOG: i32 = 10;         // constant
static ORGOG: &str = "zormpf";  // static, global-ish variable
static FOOBY: i32 = 5;          // unsafely mutable
static Z_ERRMSG : [&str;2] = ["need input","need more input"]; // static strings

type Valid = bool;        // typedef ( make your own type names )

let mut v = vec![1u8,2u8,3u8];  // determine the type of expression expr by looking at rustc error
println!("{}",v.iter_mut());    // for example, if we want to know the type of v, build an error
12 |     println!("{}",v.iter_mut());   // type of v.iter_mut() is std::slice::IterMut<'_, u8>`
   |                   ^^^^^^^^^^^^ `std::slice::IterMut<'_, u8>` <- error line tells you the type
```

## Operators

```rust
1 + 2 - 3 * 4 / 5  // arithmetic add, minus, multiply, divide
7 % 5              // modulo (remainder)
& | ^              // bitwise and, or, xor
<< >>              // leftshift, rightshift, will crash on overflow
// note that in C, overflowing << is actually undefined.
// Rust has multiple versions, each defined.
a.rotate_left(3)   // circular bit rotation, out of left -> in at right
a.wrapping_shl(3)  // this destroys the left-most bits that would cause overflow
a.overflowing_shl(4) // returns tuple (value,did_it_overflow)
a.rotate_right(4)  // circular bit rotation, wrapping around
!                  // bitwise not
a == b != c < d <= e > f >= g  // logical comparison
a && b || c ! d    // logical boolean, and, or, not

let a = 5;         // pointer + dereference example
let b = &a;        // &a is 'address of a' in computers memory
let c = *b;        // *b is contents of memory at address in b (dereference)
print("{}",c);     // 5

overloading: see struct
```

## Run time errors, Crashing, panic, except, unwrap, Option, Result

```rust
panic!("oops");             // panic!() instantly crashes program
let v = vec![3,4,5];
let a = v[0];               // ok, normal lookup, a is 3
let b = v[12];              // will call panic! at runtime, v[12] doesn't exist
```

```bash
$ export RUST_BACKTRACE=1
$ cargo run    # will tell you exact line where panic occured, with call stack trace
```

Option - a basic way to deal with functions that might not work.

```
let c = v.get(12);          // this will not crash, c will instead be an Option
print!("{:?}",v.get(12));   // prints the word "None", Option can be None or Some
print!("{:?}",v.get(0));    // prints the word "Some(3)"
let e = v.get(0).unwrap();  // ok, 'unwrap' the Option returned by get(0), e is now 3
let d = v.get(12).unwrap(); // this crashes. 'unwrap' of a None Option will call panic!
let f = v.get(5).unwrap_or(&0); // unwrap_or gives a value if get() is None. f = 0

```

Result - is like Option but instead of Some and None, there is Ok() and Err():

```rust
// first define some function that returns Result... which means it
// returrns Err(u8) if something goes wrong, and Ok(&str) if it goes right.
fn calculate_blorg_level(some_data: &[u8]) -> Result<u8, &'static str> {
    match some_data[0] {
    	255=>Err("we cannot calculate blorg if data begins with 255"),
        _=>Ok((some_data[0]+some_data[1]*17).rotate_right(3)),
    }
}

// now we want to use this calculation function.
// sometimes we need to catch whether the Result is Err() or OK()
fn space_transmit_function() {
	match calculate_blorg_level([1,2,3]) {
		Err(why)=>{println!("Bad blorg, space transmit inoperative: {}",why);},
		Ok(n) => { begin_space_transmission(n); }
        }
}

// but other times we want to use the calculation function
// but it's OK if we don't have a perfect OK() result, we can
// assume it's 5 and use unwrap_or(5) if we get an Err()
fn pizza_transmit_function() {
	let m = calculate_blorg_level([7,8,9]).unwrap_or(5);
	set_pizza_delivery_level(m);
}
```

Note our Result can return two different things, a u8 or a str, but the u8 will be wrapped inside Ok() while the str would
be wrapped inside an Err(). Not 'catching' a Result when you call calcualte_blorg_level() will show an error at compile time.

More examples with options:

```

let x = do_somthing_that_might_not_work(); // Option can help handle errors
match x {
	Some(x)=>println!("OK!"),
	None=>println!("sad face"),
}

if let Some(x) = do_something_that_might_not_work() {
	println("OK!");
} // if None, do nothing.

```

Option in particular can prevent the use of null pointers, preventing crashes one might see in C/C++.

```
struct Owlgr {
	name: String,
	fiznozz: Option<String>     // in C++ this might be a *char which could init as NULL
}

let owls = [Owlgr{name:"Harry".to_string(),fiznozz:None},
            Owlgr{name:"Tom".to_string(),fiznozz:Some("Zoozle".to_string())}];

for owl in &owls {
	match &owl.fiznozz {
		None=>println!("Owlgr named {} has no fiznozz!",owl.name),
		Some(x)=>println!("Owlgr named {} has fiznozz of {}",owl.name,x),
	}
    }
}

// note that we did not have to check for null pointers, nor derefernece any
// pointer. if we forgot to check for None, the compiler would give an error.

```

Note that there are no Exceptions. panic/Option/Result/multi-value-return are used instead.

## Unit tests, integration tests

Test functions are marked with the `#[test]` attribute.

Unit tests should be placed in the same file as the code being tested.

```rust
./src/lib.rs:

pub fn process(v:&mut Vec<u8>)->&Vec<u8>{ v.update(|x| f(x)) } // main function called by users
fn f(x:u8)->u8 { x*x }   // small piece of our code, to test in unit testing

#[cfg(test)]        // cfg -> section will only compiled during 'cargo test'
mod tests {         // namespace helper
    use super::*;   // bring in our functions above
    #[test]         // next function will be a single test
    fn test_f() { assert!(f(4)==16); } // test f() by itself (unit)
}
```

Integration tests, for overall crate, lives under ./tests/\*.rs

```rust
./tests/file.rs:         // will only be built dring 'cargo test'
extern crate mypackage;  // include package we are testing
#test                    // treat next function as a test
fn bigtest() {           // not a unit test. instead, test overall code
	let mut d = vec![1,2,3];               // set up some typical data users would have
	let expected_results = vec![1,4,9];    // some results we expect
	assert!(process(d)==expected_results); // test what a user would typically call, process()
}
```

```bash
$ cargo test           # test build, will include cfg(test) sections
-> test_f passed       # cargo reports on passed tests
-> test_bigtest failed # cargo reports on failed tests
```

## Documentation

`rust-doc` and `cargo` doc allow automatic building of html documentation
for code. precede documentation of your code with three slashmarks
instead of the normal two slashmarks, like so:

```rust
/// blorg() returns the blorgification of input x
/// # Details
/// this code implements the krishnamurthi procedure
/// for blimfication of zorgonautic primes
/// # Arguments
/// * `x` - typically a square number
/// # Safety
/// Cannot panic unless x overflows u64
/// # Example
///     let n = blorg(36);
fn blorg(x:u64)->u64 {
   x+x*x
}
```

Then run rust-doc or cargo doc and view the result.

```bash
$ cargo doc --open
$ firefox target/doc/cratename/index.html
```

Good examples of the results are on https://crates.io



## Little programs


### Guess a number

```rust
fn main() {
    let secret_number = rand::thread_rng().gen_range(1..101);

    loop {
        println!("Please input your guess");

        let mut guess = String::new();
        io::stdin()
            .read_line(&mut guess)
            .expect("Failed to read line");

        let guess: u32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        println!("You guessed: {}", guess);

        match guess.cmp(&secret_number) {
            Ordering::Less => println!("too small!"),
            Ordering::Greater => println!("too big!"),
            Ordering::Equal => {
                println!("you got it!");
                return;
            }
        }
    }
}
```
