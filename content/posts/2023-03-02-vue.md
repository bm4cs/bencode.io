---
layout: post
draft: false
title: "Vue"
slug: "vue"
date: "2023-03-02 20:45:36+11:00"
lastmod: "2023-03-02 20:45:36+11:00"
comments: false
categories:
  - webdev
tags:
  - vue
  - vuejs
  - web
  - frontend
  - javascript
---

A bunch of (scattered) tips and resources as I experiment with Vue.

- Basics: [`Overview`](#overview), [`Anatomy`](#anatomy), [`Event handling`](#events), [`Watchers`](#watchers), [`Computed`](#computed)
- Components: [`Components`](#components), [`Props`](#props)

## Overview

A bunch of (scattered) tips and resources as I experiment with Vue.

> an open-source model–view–viewmodel front end JavaScript framework for building user interfaces and single-page applications, created by Evan You

Helpful resouces:

- [Read the offical docs](https://vuejs.org/guide/quick-start.html#using-vue-from-cdn)
- [Examples](https://vuejs.org/examples/#hello-world)
- [Vue cheat sheet](https://boussadjra.github.io/vue-cheat-sheet/guide/)
- [Awesome Vue](https://github.com/vuejs/awesome-vue)
- [Vue.js devtools](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=en)
- [Volar VSCode extension](https://marketplace.visualstudio.com/items?itemName=Vue.volar)
- [Built-in Directives](https://vuejs.org/api/built-in-directives.html)

## General advice

- It's best to stick to conventions of the web and use `camelCase` in your script and `kebab-case` in your template.

Here is a bare bones vue app:

```html
<div id="app">
  <p v-if="message.length % 2 === 0">Even: {{ message.toUpperCase() }}</p>
  <p v-else>Odd: {{ message }}</p>
  <ul v-for="item in listOfNumbers">
    <li>
      {{ item.id }}
      <ul>
        <li v-for="number in item.list">{{ number }}</li>
      </ul>
    </li>
  </ul>
</div>

<script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
<script>
  const { createApp } = Vue

  const app = createApp({
    data() {
      return {
        message: 'Hello it works',
        listOfNumbers: [
          {
            name: 1,
            id: '6a887cd2-f0bf-4321-b192-92016f82a883',
            list: [1, 2, 3]
          },
          {
            name: 2,
            id: '8d14d90b-2d47-473e-8293-d5c324111d0d',
            list: [1, 2, 3]
          }
        ]
      }
    }
  })

  app.mount('#app')
</script>
```

### Notes

- The CDN include is all that is needed. No complex build toolchain (although that's a well supported option)
- Templates use the mustache syntax `{{ }}`
- [Directives](https://vuejs.org/api/built-in-directives.html) are prefixed with `v-` to indicate that they are special attributes provided by Vue, they apply special reactive behavior to the rendered DOM, keeping the HTML in-sync with the data that it's bound to
- The `v-if` directive will destroy elements from the DOM as the condition is toggled (potentially expensive depending on the scenario), if desired the `v-show` directive will preserve DOM but visually toggle using CSS


### Tips

Cleaner arrow syntax:

```javascript
// traditional syntax
const app = createApp({
  data() {
    return {
      message: 'Hello it works',
    }
  }
})

// arrow operator
const app = createApp({
  data: () => ({
    message: 'Hello it works',
  })
})
```


## Anatomy

Vue component conceptual model (the forest view):

![vue component anatomy](/images/vue-anatomy.png)


## Events

[Event Handling Docs](https://vuejs.org/guide/essentials/event-handling.html#method-handlers)

Reactive event listening (write) is done with the `v-on` directive, or the `@` shorthand: `v-on:click="handler"` is the same as `@click="handler"`

The inverse direction (read) `v-bind` directive can similarly be used, with the colon `:` shorthand `<HaltCatchStatistics :characters="characterList">`

Vue has the notion of [methods](https://vuejs.org/guide/essentials/reactivity-fundamentals.html#declaring-methods), which are cleverly component scoped, including the notorious `this` value which is rewired to only refer to the component instance.

Gotcha: Avoid arrow functions for methods, as it prevents Vue from binding the appropriate `this`

```html
<button v-on:click="incrementCount">Increment</button>

<div>
  <label for="incrementAmount">Icrement by:</label>
  <input 
    type="number" 
    v-bind:value="incrementAmount"
    v-on:input="changeIncrementAmount"
  />
</div>

<script>
  const { createApp } = Vue
  const app = createApp({
    data() {
      return {
        count: 10,
        incrementAmount: 8,
      }
    },
    methods: {
      incrementCount() {
        this.count += this.incrementAmount
      }
    }
  })
</script>
```

Notice above how the read (`v-bind`) and write (`v-on:input`) are being handled. But isn't there a reactive two way binding?

Enter [`v-model`](https://vuejs.org/api/built-in-directives.html#v-model):

```html
<input type="number" v-model="incrementAmount" />
```

`v-model` will also intelligently type (in the above case, numeric) the variable, so it won't treat an int as a string.


## Watchers

Handy in cases where we need to perform "side effects" in reaction to state changes - for example, changing another piece of state based on the result of an async operation.

With the Options API, we can use the `watch` option to trigger a function whenever a reactive property changes:

Use with care, as watchers can trigger a cascade of re-rendering work.

```javascript
export default {
  data() {
    return {
      question: '',
      answer: 'Questions usually contain a question mark. ;-)'
    }
  },
  watch: {
    // whenever question changes, this function will run
    question(newQuestion, oldQuestion) {
      if (newQuestion.includes('?')) {
        this.getAnswer()
      }
    }
  },
  methods: {
    async getAnswer() {
      this.answer = 'Thinking...'
      try {
        const res = await fetch('https://yesno.wtf/api')
        this.answer = (await res.json()).answer
      } catch (error) {
        this.answer = 'Error! Could not reach the API. ' + error
      }
    }
  }
}
```


## Computed

[Computed properties](https://vuejs.org/guide/essentials/computed.html) are a handy slice of vue magic. Basically think of them as a function, that will only be exercised if the underlying data on which it is based changes. In others words a function that automagically caches.

```javascript
export default {
  data() {
    return {
      author: {
        name: 'John Doe',
        books: [
          'Vue 2 - Advanced Guide',
          'Vue 3 - Basic Guide',
          'Vue 4 - The Mystery'
        ]
      }
    }
  },
  computed: {
    // a computed getter
    publishedBooksMessage() {
      // `this` points to the component instance
      return this.author.books.length > 0 ? 'Yes' : 'No'
    }
  }
}
```


## Components

Involves creating `vue` files that follow a standard blueprint, usually a `<script>` and `<template>` blocks:

```html
<script>
export default {
  data: () => ({
    count: 10,
    incrementAmount: 8
  }),
  methods: {
    incrementCount() {
      this.count += this.incrementAmount
    }
  },
}
</script>

<template>
  <h1>Counter</h1>
  <p>{{ count }}</p>
  <button v-on:click="incrementCount">Increment Count</button>
  <h1>{{ incrementAmount }}</h1>
  <div>
    <label for="incrementAmount">Increment by:</label>
    <input type="number" v-model="incrementAmount" />
  </div>
</template>
```

Consuming the component involves importing and registering it using the `Options` API:

```html
<script setup lang="js">
import Counter from './components/Counter.vue'

export default {
  components: {
    Counter
  }
}
</script>
```

Then actually using it within the template:

```html
<main>
  <Counter />
</main>
```

Component tips:

- Get into habbit of using multi-word components, as the base HTML spec can shift.
- Vue supports kebab or pascal case out of the box e.g. `<FooCounter />` or `<foo-counter />` both work well.


## Props

[Props](https://vuejs.org/guide/components/props.html) are an explicit way for components to define their API to the outside world. 

They are self documenting in that they not only define the name of the props, but can also specify their type and if they are mandatory or optional.

Remember `props` are intended for reads only, and NEVER for mutation.

```javascript
export default {
  props: {
    title: String,
    likes: Number,
    description: {
      type: String,
      default: "A silly default string"
    },
    characters: {
      type: Array,
      required: true
    },
    user: {
      type: Object,
      required: true
    }
  }
}
```

Types are stanard JS types, such as `Function`, `Object`, `String`, `Number` and so on.

Conversly you can just be lazy with your `props`:

```javascript
export default {
  props: ["characters"]
}
```

Providing the props should follow kebab case (although camelCase works just fine) to align with how HTML attributes are defined and used:

```html
<MyComponent greeting-message="hello" />
```

Remember for reactive data binary we must `v-bind` to it:

```html
<UserCard v-bind:user="userData" />
```

Or more consisely:

```html
<UserCard :user="userData" />
```


## Lifecycle hooks

[Lifecycle hooks](https://vuejs.org/api/options-lifecycle.html) provide an opportunity to run custom logic during the many phases a component goes through:

These can simply be registered right inside the Options API hunk within the component, like so:

```javascript
mounted() {
  console.log("mounted()")
}
```


## Emitting events

At first, it may seem intuitive to pass a function down to child components as a `prop`. However, this is a code smell. Why? Because it couples (or bleeds) behavior between components, which may become not so obvious and difficult to maintain in a complete component tree.

Following the pub/sub event model that is so natural to the way the web works (think `onclick`), vue makes it easy for components to emit events that can be observed by their parents.

In vue 3, the `Options` API now provides an `emits` setting.

On the parent component `App.vue`:

```javascript
<script>
import UserCard from "./components/user-card.vue"

export default {
  components: {
    UserCard
  },
  data: () => ({
    userData: {
      name: "Ben Mac",
      favoriteFood: "Poke bowl",
    }
  }),
  methods: {
    changeName() {
      this.userData.name = "Rob Pike"
    }
  }
}
</script>

<template>
  <header>
    <div class="wrapper">
      <!-- syntactic sugar: ':' is v-bind and '@' is 'v-on' -->
      <UserCard :user="userData" @change-name="changeName()" />
    </div>
  </header>
</template>
```


On the child component `user-card.vue`:

```html
<script>
export default {
  // defines inputs
  props: {
    user: {
      type: Object,
      required: true
    }
  },
  // defines outputs
  emits: ['change-name']
}
</script>

<template>
  <h1>User: {{ user.name }}</h1>
  <p>Favorite food: {{ user.favoriteFood }}</p>
  <button @click="$emit('change-name')">Change Name</button>
</template>
```

```javascript
```


Event tips:

- The vue devtools have a handy timeline feature, that tracks component events
- The `emits` section in the Options API is new to vue 3, however the core `$emit` function is identical to vue 2. In a nutshell, vue 3 allows you to document the events in a similar way to `props`.
- The `emits` section, is actually quite powerful, allowing post-event data validation if you choose. See [event validation](https://vuejs.org/guide/components/events.html#events-validation)


## Slots

Components can accept props, which can be JavaScript values of any type. But how about template content?


```html
<button class="fancy-btn">
  <slot></slot> <!-- slot outlet -->
</button>
```

The `<slot>` element is a slot outlet that indicates where the parent-provided slot content should be rendered.

```html
<FancyButton>
  Click me! <!-- slot content -->
</FancyButton>
```
