---
layout: post
draft: true
title: "Go"
slug: "go"
date: "2019-10-05 19:02:44"
lastmod: "2020-12-26 22:13:18"
comments: false
categories:
  - dev
tags:
  - golang
---

- [GOPATH](#gopath)
- [Run, build and install](#run-build-and-install)
- [Dependencies](#dependencies)
- [Formatting](#formatting)
- [Documentation](#documentation)
- [Structuring a source tree](#structuring-a-source-tree)
- [The lang](#the-lang)
  - [Variables](#variables)
  - [Control structures (if, switch and for)](#control-structures-if-switch-and-for)
    - [if](#if)
    - [switch](#switch)
    - [for](#for)
  - [I/O](#io)
    - [fmt](#fmt)
    - [CLI](#cli)
      - [Args](#args)
      - [Flags](#flags)
- [Types](#types)
  - [Type conversion](#type-conversion)
  - [Strings](#strings)
    - [Unicode](#unicode)
    - [String literals](#string-literals)
  - [Numbers](#numbers)
    - [Integers](#integers)
    - [Bitwise operations](#bitwise-operations)
    - [Floating point](#floating-point)
  - [Constants](#constants)
  - [Pointers](#pointers)
- [Functions](#functions)
  - [Grouped parameters types](#grouped-parameters-types)
  - [Variadic functions](#variadic-functions)
  - [Multiple return values](#multiple-return-values)
  - [Named return values](#named-return-values)
  - [Recursion](#recursion)
  - [Deferred functional calls](#deferred-functional-calls)
  - [Functions as values](#functions-as-values)
  - [Function literals (anonymous functions)](#function-literals-anonymous-functions)
  - [Passing functions to functions](#passing-functions-to-functions)
  - [Closures](#closures)
- [Error Handling](#error-handling)
  - [Error handling strategies](#error-handling-strategies)
    - [Propagate to caller](#propagate-to-caller)
    - [Retry](#retry)
    - [Log and continue](#log-and-continue)
    - [Log and exit](#log-and-exit)
  - [pkg/errors](#pkgerrors)
  - [Panic and Recover](#panic-and-recover)
- [Packages and Libraries](#packages-and-libraries)
  - [Package aliases](#package-aliases)
  - [Imported unused packages for side effects](#imported-unused-packages-for-side-effects)
- [Vim setup](#vim-setup)
- [Libraries](#libraries)
  - [Middleware](#middleware)
  - [Web](#web)

[Effective Go](https://golang.org/doc/effective_go.html) is a howto on writing idiomatic Go.

# GOPATH

It is convention for all Go code to be hosted in a single workspace, and `GOPATH` points to the root of this workspace.

A Go workspace contains one or more project repositories. Each repository is independently version controlled.

Inject this into `~/.profile` and include the `$GOPATH/bin` on `PATH`:

    export GOPATH=$HOME/go
    export PATH="$PATH:$GOPATH/bin"

Using `go env` validate `GOPATH`:

    cd `go env GOPATH`

# Run, build and install

Source is placed within the `src` dir within `$GOPATH` like `$GOPATH/src/github.com/bm4cs/cool-app/main.go`

To just run a program, without building a binary output:

    $ go run main.go
    hello world

To build a statically linked binary output:

    $ go build
    $ file demo
    demo: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked

Cross compiling is available too:

    $ GOOS=windows go build
    $ file demo.exe
    demo.exe: PE32+ executable (console) x86-64 (stripped to external PDB), for MS Windows

The binary can be written to `$GOPATH/bin` (or `$GOPATH/pkg` for libraries) which is normally on the `PATH`:

    $ go install
    $ ls $GOPATH/bin | grep demo
    demo

# Dependencies

TODO: modules

    $ go get github.com/golang/example/hello
    $ $GOPATH/bin/hello
    Hello, Go examples!

# Formatting

Format a file to `stdout`:

    $ gofmt main.go

Diff:

    $ gofmt -d main.go

Update (write) the original source file:

    $ gofmt -w main.go

# Documentation

Local CLI help:

    $ go doc fmt Printf

    func Printf(format string, a ...interface{}) (n int, err error)
    Printf formats according to a format specifier and writes to standard
    output. It returns the number of bytes written and any write error
    encountered.

Local documentation HTTP server:

    $ godoc -http :7070

# Structuring a source tree

[project-layout](https://github.com/golang-standards/project-layout) curates common conventions followed by the community.

Check out [go-structure-examples](https://github.com/katzien/go-structure-examples) for flat, layered, modular and DDD based layouts.

# The lang

## Variables

    var a int //set to 0
    var b int = 10
    var d, e, f bool
    var (
        g int
        h string
        i int = 1234
        j, k, l bool
    )

Inside a func can use _short variable declaration_ (a declaration and assignment in one step):

    m := 1
    n, o := 2, 3

Assignments:

    e, f = f, e
    a := 11
    a, p := 100, 200

The blank identifer (for ignoring outputs):

    a, _ := f()
    g(a)

## Control structures (if, switch and for)

### if

Go uniquely supports an _initialisation statement_, within the if statement:

    if err := f(x); err != nil {
        return err
    }

Ternary operators are not supported, due to readability.

### switch

Case statements do not fallthrough in Go.

Supports vanilla style:

    var model string
    //...
    switch model {
        case "dell":
            // Do something
        case "acer":
            // Do something else
        case "compaq":
            // Do something different
        default:
            // Do nothing
    }

However, unlike many langs go supports another switch-expressionless form:

    var velocity int
    //...
    switch {
        case velocity == 0 || velocity == 1:
            //...
        case velocity >= 10:
            //...
        case f(velocity) >= f(100):
            //...
    }

If fallthrough is required there are a couple of options:

    case velocity >= 10:
        //...
        fallthrough

Or pile up the case statements with multiple expressions:

    switch motion {
        case "walk", "run":

### for

The `for` keyword covers off all loop types in Go. No support for `while`, `do`, `until` loops exist.

- For loop `for i=0; i<10; i++`
- While loop `for i<10`
- Infinite loop `for`
- Enumerable iteration `for i, v := range s`

## I/O

### fmt

The `fmt` (fumpt) package does formatted I/O.

- parameters are separated by spaces by default
- it can handle a variety of input types
- explicit argument indexes (one-based) are supported `fmt.Sprintf("%[2]d %[1]d\n", 11, 22)`

Supported [format verbs](https://golang.org/pkg/fmt/) are like C, but simpler.

- `%v` value in default format
- `%#v` print the value in valid Go syntax, handy for dumping structs or slices
- `%t` boolean
- `%d` base 10
- `%b` base 2
- `%x` base 16
- `%s` raw string
- `%T` type of the value

```go
r, g, b := 124, 87, 3
// ...as #7c5703  (specifying hex format, fixed width, and leading zeroes)
fmt.Printf("#%x%x%x\n", r, g, b)
// ...as rgb(124, 87, 3)
fmt.Printf("rgb(%d, %d, %d)\n", r, g, b)
// ...as rgb(124, 087, 003) (specifying fixed width and leading zeroes)
fmt.Printf("rgb(%03d, %03d, %03d)\n", r, g, b)
// ...as rgb(48%, 34%, 1%) (specifying a literal percent sign)
fmt.Printf("rgb(%d%%, %d%%, %d%%)\n", r*100/255, g*100/255, b*100/255)
// Print the type of r.
fmt.Printf("%v\n", r)
```

Reading input done with `fmt.Scan`, `fmt.Scanln` and `fmt.Scanf`

```go
var s string
var n int
cnt, err := fmt.Scan(&s, &n)
fmt.Println(cnt, s, n, err)
```

`Scanf` will parse input precisely as the format string specifies (in the snippet below: an 'a' character, followed by a space, a string, a newline, then an integer):

    fmt.Scanf("a %s\n%d", &label, &age)

Fuller example:

```go
var n1, n2, n3, n4 int
var f1 float64

// Scan the card number.
str1 := "Card number: 1234 5678 0123 4567"
_, err := fmt.Sscanf(str1, "Card number: %d %d %d %d", &n1, &n2, &n3, &n4)
if err != nil {
    fmt.Println(err)
}
fmt.Printf("%04d %04d %04d %04d\n", n1, n2, n3, n4)

// Scan the numeric values into a floating-point variable, and an integer.
str2 := "Brightness is 50.5% (hex #7ffff)"
_, err = fmt.Sscanf(str2, "Brightness is %f%% (hex #%x)", &f1, &n1)
if err != nil {
    fmt.Println(err)
}
fmt.Println(f1, n1)
```

### CLI

#### Args

- complete command line is available via an array named `os.Args`
- use `len()` to size `os.Args`
- iterate over individual args with `range` like `for _, e := range os.Args`

#### Flags

A standard package for parsing CLI flags `./coolprog -verbose -count=7`

The `flag` package works by creating a pointer for each flag. Flags are then evaluated with `flag.Parse()`.

```go
verbose := flag.Bool("verbose", false, "Print verbose log outputs")
count := flag.Int("count", 1, "Number of items to collect")
flag.Parse()
fmt.Printf("verbose = %t, count = %d\n", *verbose, *count)
```

When working with the flag pointers, they need to be dereferenced with the `*` syntax.

By declaring variables explicitly can avoid the need to deref pointers:

```go
var max int
flag.IntVar(&max, "max", 1, "The maximum number of shares to buy on a triggered event")
```

POSIX flags support both short and long forms e.g. `-n --name`. There are many community packages that support this such as `pflag`.

# Types

## Type conversion

Many langs support type casting. Go provides conversion functions.

```go
var u uint = 64
var u64 unit64 = uint64(u)
```

When truncation is needed, go always rounds down towards zero.

## Strings

- the `strings` package is where many string utility functions live for working with bytes (e.g. `strings.IndexByte`) and runes (e.g. `strings.IndexRune`)
- the `strconv` package provides many conversions (such as `Atoi`, `Itoa`, `FormatInt`, `ParseBool`, `FormatFloat`, `ParseFloat`)
- they immutable (mutability is possible using a slice of bytes)
- treated as sequences of bytes with arbitrary values, even a null byte, differentiating them from C strings
- substrings `s[1:4]` would return characters `his` in the below string (the second index hits the first byte after the substring)
- substring shortcuts `s[:4]` and `s[4:]`

Sample string:

    | T | h | i | s |   |
      ^   ^   ^   ^   ^
      0   1   2   3   4

### Unicode

Make sure to learn about whats available in the [unicode](https://golang.org/pkg/unicode/) package. Many identification and conversion utilities such as `IsSpace` or `ToTitle` exist.

Go uses UTF-8 to encode unicode. Recall UTF-8 is a variable length encoding (i.e. it can use 1-byte or upto 4-bytes).

    fmt.Println(len("a")) // 1
    fmt.Println(len("Ã¤")) // 2
    fmt.Println(len("èµ°")) // 3

We can see the UTF-8 encoding in action here, with simple English characters using only a single byte, with the more esoteric characters using 2 or more bytes depending how deep into the unicode listing they fall.

Go allows you to treat string both a the byte and character level. At the character level, the unit of a character is called a `rune`. A `rune` is just an alias for a `int32`.

Runes are presented by `range` when iterating over a string:

```go
for i, e := range "abÃ¤èµ°." {
    fmt.Println("range:", i, e, string(e))
}

// range: 0 97 a
// range: 1 98 b
// range: 2 228 Ã¤
// range: 4 36208 èµ°
// range: 7 46 .
```

Strings can be worked with at both the byte and rune levels. UTF-8 generally makes this work out fine:

```go
fmt.Println("IndexByte:", strings.IndexByte("abÃ¤èµ°.", '.')) // IndexByte: 7
fmt.Println("IndexRune:", strings.IndexRune("abÃ¤èµ°.", 'èµ°')) // IndexRune: 4
```

The [unicode/utf8](https://golang.org/pkg/unicode/utf8/) package provides rune aware functionality, such as [RuneCountInString](https://golang.org/pkg/unicode/utf8/#example_RuneCountInString).

```go
str := "Hello, ä¸–ç•Œ"
fmt.Println("bytes =", len(str)) // bytes = 13
fmt.Println("runes =", utf8.RuneCountInString(str)) // runes = 9
```

Showcase of some `unicode` and `strings` functionality:

```go
import (
	"fmt"
	"os"
	"strings"
	"unicode"
)

func acronym(s string) (acr string) {
	afterSpace := false

	for i, e := range s {
		if (afterSpace || i == 0) && unicode.IsLetter(e) && unicode.IsUpper(e) {
			acr += string(e)
			afterSpace = false
		}
		if unicode.IsSpace(e) {
			afterSpace = true
		}
	}

	return acr
}

func main() {
	s := "Pan Galactic Gargle Blaster"
	if len(os.Args) > 1 {
		s = strings.Join(os.Args, " ")
	}
	fmt.Println(acronym(s))
}
```

### String literals

- the usual `\t` tabs, `\n` newline
- `\x61` is a raw byte in hex, evaluating to the character `a`
- `\142` is a raw byte in octal
- multi-line literals are supported using backticks

## Numbers

- The `bool` type is strictly handled by go, and no auto-type conversion is supported (e.g. `if 1`).
- Conditions can evaluate a boolean type, a comparison operation or a bool func.

### Integers

Go supports integers explicitly; their signage and size.

| Signed  | Unsigned | Bytes |
| ------- | -------- | ----- |
| `int8`  | `uint8`  | 1     |
| `int16` | `uint16` | 2     |
| `int32` | `uint32` | 4     |
| `int64` | `uint64` | 8     |

Several aliases to these types exist:

- `byte` is a `uint8`
- `rune` is a `int32`
- `int` and `uint` are CPU platform specific

Arithmetic overflows are silently discarded.

```go
var a uint8 = 250
a = a + 10 // result is larger than 256, so a ends up being 4
```

### Bitwise operations

As the usuals, such as `a & b` for bitwise AND, `a >> n` right shift by n bits, `a &^ b` for a AND NOT b (aka bit clear, all the bits in b set to 1 will be cleared in the result), etc.

```go
// var a uint8 = 64
// uint8 is 8-bits wide, and looks like this at the bit level:
// | 256 | 128 |  64 |  32 |  16 |  8 |  4 |  2 |  1 |  0 |
// |   0 |   0 |   1 |   0 |   0 |  0 |  0 |  0 |  0 |  0 |
//
// bit shifting to the right 1 bit
// a = a >> 1
// | 256 | 128 |  64 |  32 |  16 |  8 |  4 |  2 |  1 |  0 |
// |   0 |   0 |   0 |   1 |   0 |  0 |  0 |  0 |  0 |  0 |

var a uint8 = 64
a = a >> 1 //32
```

### Floating point

- Supports IEEE 754 real numbers with the `float32` and `float64` types.
- Prefer `float64`
- Decimal fractions cannot be accurately modelled using the binary system. Never use when accuracy is needed, such as for money calculations.

The float binary problem:

    $ bc
    bc 1.07.1
    obase=2
    scale=40
    1/10
    .0001100110011001100110011001100110011001100110011001100110011001100\
    110011001100110011001100110011001100110011001100110011001100110011

## Constants

Go supports typed and untyped constants, in either the singular or multiple forms.

Go constants can represent these types:

- a unicode rune, `'ðŸ˜€'` `'\377'` `'\u266B'` `'\U0001F600'`
- integers, as decimal `1337`, octal `01337`, or hex `0x1CAFE42`
- floats `123.456e7`, `123e20`, `1.234`, `.71828`, `2.e7`, `.5e-10`
- strings, any sequence of unicode runes or escape sequences, `"A string \U0001F600"`
- booleans

Enumerations are possible with the `iota` keyword. Reassigning `iota` in the same list of consts has no effect.

```go
const kilo = 1024
const pi32 float32 = 3.1415926535897932384

const (
    cint = 299792458
    ctitle = "Theo de Raadt created OpenBSD in 1995 by forking NetBSD"
)


// all constants are set to 12
const (
    twelve = 12
    dozen
    months
)

const (
    zero = iota
    one
    two
    three
    four
)

// iota calculation
const (
    ten = iota * 10 + 10
    twenty
    thirty
)


// iota bit shifting
const (
    read    = 1 << iota  // 0001
    write                // 0010
    execute              // 0100
    isLink               // 1000
)
```

## Pointers

- Supports C like `*type` pointer type, `&` address of, and `*p` pointer indirection
- Pointers have a default value of `nil`
- Its illegal to point to an arbitrary (literal) address, or a constant
- When `nil`, pointer indirection causes a panic
- Can compare pointer addresses `p1 == p2`, or the values they point to `*p1 == *p2`
- The built-in `new()` allocates variable and returns a pointer to it `p := new(int)`

```go
var a int = 1337
var p *int = nil

p = &a
fmt.Println("p's value is a's address", p)
fmt.Println("p's value yields a's value", *p)
```

Result:

    p's value yields a's value 1337
    p's value is a's address 0xc0000b6010

The `new()` operator returns a pointer to an un-named variable:

```go
p := new(int32)
*p = 64
```

# Functions

- functions are first class objects in Go (i.e. can be assigned to a variable)
- subsequent parameters of the same type can be grouped
- named parameters are NOT supported (i.e. must pass in the order specified)
- variadic functions are supported (i.e. the ability to take an arbitrary number of parameters of the same type)
- functions can return multiple values (types must be enclosed in pathentheses)
- return values can be named, which get declared as variables within the scope of the function

## Grouped parameters types

```go
func f(n, m int, s string) {
    fmt.Println("A function with grouped parameters:", n, m, s)
}
```

## Variadic functions

```go
func f(s ...string) {
    for _, str := range s {
        fmt.Print(str + " ")
    }
    fmt.Println()
}
func main() {
    f("clear", "is", "better", "than", "clever")
}
```

## Multiple return values

```go
func f() (int, string, error) {
    return 0, "ok", nil
}

n, s, err := f()
```

## Named return values

```go
func f() (n int, s string, err error) {
    n = 5
    s = "high five!"
    return // Don't do this - it works, but it can be confusing
}
```

## Recursion

```go
func factorial(n int) int {
    if n == 0 {
        return 1
    }
    return n * factorial(n - 1)
}
```

## Deferred functional calls

Using `defer` will "queue" a function call until the point where the calling function itself exits.

This is particularly useful in simplifying a function that has multiple exit points, needing to perform the same resource cleanup (e.g. `f.Close()`) at all return points.

Instead, just ensure it gets done once at the functions end with `defer`.

```go
func f() error {
    f, err := os.Open("foo.go")
    if err != nil {
        return err
    }
    defer f.Close()
    fmt.Println(f.Name())
    if f.Name() == "foo.go" {
        return nil
    }
    // More code, maybe more exit points
    return nil
}
```

## Functions as values

Functions being first class objects, means you can throw them around like variables.

Note the `funcVar` declaration below, there is no need to name parameters.

```go
func f1(s string) bool {
    return len(s) > 0
}

func f2(s string) bool {
    return len(s) < 4
}

var funcVar func(string) bool

func main() {
    funcVar = f1
    fmt.Println(funcVar("abcd"))
    funcVar = f2
    fmt.Println(funcVar("abcd"))
}
```

## Function literals (anonymous functions)

```go
funcVar = func(s string) bool {
    return len(s) > 4
}
```

Its possible to evaluate the function literal after defining it, which can be useful when creating `goroutines` in a loop:

```go
var result string = func() string {
    return "abcd"
}()
```

## Passing functions to functions

As first class objects, in addition to being treated as variables, this translates over to function parameters in the same way.

```go
func f1(s string) bool {
    return len(s) > 0
}

func f2(s string) bool {
    return len(s) < 4
}

func funcAsParam(s string, f func(string) bool) bool {
    return f(s + "abcd")
}

func main() {
    fmt.Println(funcAsParam("abcd", f1))
}
```

## Closures

When a function literal is defined within another function.

Closures get access to the local variables (i.e. the call stack) of the outer function, even after the lifetime of the outer function.

```go
func newClosure() func() {
    var a int
    return func() {
        fmt.Println(a)
        a++
    }
}

c := newClosure()
c()
c()
c()
```

# Error Handling

- Unlike other langs, exceptions are NOT supported.
- Go takes a different standpoint, error handling is instead part of normal control flow logic
- Expected errors are simply returned to the caller (Go functions can return multiple things, its convention for `error` to be the last return value of functions)
- Caller should always check each returned `error` before moving forward
- Error handling strategies: propagate, retry, log and continue, or log and exit
- A `panic` unlike an `error`, are used to communicate exceptional errors or serious failures
- A `panic` results in a controlled crash

## Error handling strategies

### Propagate to caller

- while the raw `error` can simply be returned, its practice to wrap a new error message prior to propagating
- avoid newline characters in messages for grep-ability.

```go
func propagate(i int) error {
    if err := verify(i); err != nil {
        return fmt.Errorf("propagate: %s", err)
    }
    return nil
}
```

### Retry

For transient errors, like a failing network link.

- wait a time period before retrying
- try a different port, file name, IP, reduced size, etc
- fallback to default values

```go
func retry(i int) error {
    err := propagate(i)
    if err != nil {
        err = propagate(i / 2)
        if err != nil {
            return fmt.Errorf("retry: %s", err)
        }
    }
    return nil
}
```

### Log and continue

The `error` is no significant enough to disturb control flow. Log it and move on.

```go
func onlyLog(i int) {
    if err := retry(i); err != nil {
        log.Println("onlyLog:", err)
    }
}
```

### Log and exit

The `error` is a show stopper. The `log` package conveniently has `log.Fatal()`, `log.Fatalln()` and `log.Fatalf()`, which print and exit.

```go

```

## pkg/errors

[pkg/errors](https://github.com/pkg/errors) makes it easy to account for each `error` and its context, as errors continue to be propagated and wrapped up the call chain. By providing a simple API `errors.Wrap()` to wrap errors with call stack context before propagating, `errors.WithStack()` to print full list of error messages

```go
_, err := ioutil.ReadAll(r)
if err != nil {
        return errors.Wrap(err, "read failed")
}
```

## Panic and Recover

Pull the ejector seat; something unpredictable happened or the caller passed invalid arguments or calling context.

```go
func unexpectedError(p *int) {
    if p == nil {
        panic("p must not be nil")
    }
}

func main() {
    unexpectedError(nil)
}
```

# Packages and Libraries

Go's namespace concept.

- The `main` package represents an executable
- Any other package represents a library
- A library can contain functions, types, variables, but NO `main` function
- Libraries are a great way to break up complexity into chunks
- They are imported `import "mastergolib/dice"`. File names of imports are irrelevant.
- A simple visibility rule applies for package, a function/variable/type that starts with an uppercase letter is visible to outside users of the package.
- If a package needs some initialisation logic to fire at startup, use the `init()` hook.

```go
func init() {
    rand.Seed(time.Now().UnixNano())
}
```

## Package aliases

- Occassionally you will need to use libraries with same name, and alias can help un-ambiguise this
- Nice way to cut down long package names

```go
import "time"
import tm "github.com/someuser/time"
```

## Imported unused packages for side effects

```go
import (
    "database/sql"
    _ "github.com/mattn/go-sqlite3"
)
```

# Vim setup

1. Install the [vim-go](https://github.com/fatih/vim-go) and [coc.nvim](https://github.com/neoclide/coc.nvim) plugins. I use neovim with vimplug to do this.
2. Setup `GOPATH` and `GOBIN` env.
3. Run `vim +GoInstallBinaries` to install supporting toolchain in `GOBIN`.
4. Setup coc config by running `:CocConfig` within vim. Ensure the language server is setup for go, using the provided snippet.
5. Jump into some go code such as [vmware-tanzu/velero](https://github.com/vmware-tanzu/velero), and test `gd` goto def, and `ctrl o` to bounce back. Cursor over some func and hit `:GoDoc` to show contextual docs.
6. Congrats, you have tight integration with go toolchain thanks to `vim-go`, but also modern language intelligence thanks to LSP, `gopls` and `coc-nvim`.

# Libraries

## Middleware

- [negroni](https://github.com/urfave/negroni) idiomatic HTTP middleware
- [alice](https://github.com/justinas/alice) painless middleware chaining

## Web

- [gin](https://github.com/gin-gonic/gin) HTTP web framework
- [go-jose](https://github.com/square/go-jose) implements the Javascript Object Signing and Encryption set of standards JWE, JWS and JWT (JSON Web Encryption, JSON Web Signature and JSON Web Token)
- [gorilla](https://www.gorillatoolkit.org/) a general purpose web toolkit that solves doing context, routing, RPC over HTTP, strong typing forms to structs, secure cookies, session and websockets.
