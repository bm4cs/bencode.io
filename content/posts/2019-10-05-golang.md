---
layout: post
draft: true
title: "Go"
slug: "go"
date: "2019-10-05 19:02:44"
lastmod: "2020-08-18 19:02:47"
comments: false
categories:
    - dev
tags:
    - golang
---

-   [GOPATH](#gopath)
-   [Run, build and install](#run-build-and-install)
-   [Dependencies](#dependencies)
-   [Formatting](#formatting)
-   [Documentation](#documentation)
-   [Structuring a source tree](#structuring-a-source-tree)
-   [The lang](#the-lang)
    -   [Variables](#variables)
    -   [Control structures (if, switch and for)](#control-structures-if-switch-and-for)
        -   [if](#if)
        -   [switch](#switch)
        -   [for](#for)
    -   [I/O](#io)
        -   [fmt](#fmt)
        -   [CLI](#cli)
            -   [Args](#args)
            -   [Flags](#flags)
-   [Types](#types)
    -   [Type conversion](#type-conversion)
    -   [Strings](#strings)
        -   [Unicode](#unicode)
        -   [String literals](#string-literals)
    -   [Numbers](#numbers)
        -   [Integers](#integers)
        -   [Bitwise operations](#bitwise-operations)
        -   [Floating point](#floating-point)
    -   [Constants](#constants)
    -   [Pointers](#pointers)
-   [Libraries](#libraries)
    -   [Middleware](#middleware)
    -   [Web](#web)

[Effective Go](https://golang.org/doc/effective_go.html) is a howto on writing idiomatic Go.

# GOPATH

It is convention for all Go code to be hosted in a single workspace, and `GOPATH` points to the root of this workspace.

A Go workspace contains one or more project repositories. Each repository is independently version controlled.

Inject this into `~/.profile` and include the `$GOPATH/bin` on `PATH`:

    export GOPATH=$HOME/go
    export PATH="$PATH:$GOPATH/bin"

Using `go env` validate `GOPATH`:

    cd `go env GOPATH`

# Run, build and install

Source is placed within the `src` dir within `$GOPATH` like `$GOPATH/src/github.com/bm4cs/cool-app/main.go`

To just run a program, without building a binary output:

    $ go run main.go
    hello world

To build a statically linked binary output:

    $ go build
    $ file demo
    demo: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), statically linked

Cross compiling is available too:

    $ GOOS=windows go build
    $ file demo.exe
    demo.exe: PE32+ executable (console) x86-64 (stripped to external PDB), for MS Windows

The binary can be written to `$GOPATH/bin` (or `$GOPATH/pkg` for libraries) which is normally on the `PATH`:

    $ go install
    $ ls $GOPATH/bin | grep demo
    demo

# Dependencies

TODO: modules

    $ go get github.com/golang/example/hello
    $ $GOPATH/bin/hello
    Hello, Go examples!

# Formatting

Format a file to `stdout`:

    $ gofmt main.go

Diff:

    $ gofmt -d main.go

Update (write) the original source file:

    $ gofmt -w main.go

# Documentation

Local CLI help:

    $ go doc fmt Printf

    func Printf(format string, a ...interface{}) (n int, err error)
    Printf formats according to a format specifier and writes to standard
    output. It returns the number of bytes written and any write error
    encountered.

Local documentation HTTP server:

    $ godoc -http :7070

# Structuring a source tree

[project-layout](https://github.com/golang-standards/project-layout) curates common conventions followed by the community.

Check out [go-structure-examples](https://github.com/katzien/go-structure-examples) for flat, layered, modular and DDD based layouts.

# The lang

## Variables

    var a int //set to 0
    var b int = 10
    var d, e, f bool
    var (
        g int
        h string
        i int = 1234
        j, k, l bool
    )

Inside a func can use _short variable declaration_ (a declaration and assignment in one step):

    m := 1
    n, o := 2, 3

Assignments:

    e, f = f, e
    a := 11
    a, p := 100, 200

The blank identifer (for ignoring outputs):

    a, _ := f()
    g(a)

## Control structures (if, switch and for)

### if

Go uniquely supports an _initialisation statement_, within the if statement:

    if err := f(x); err != nil {
        return err
    }

Ternary operators are not supported, due to readability.

### switch

Case statements do not fallthrough in Go.

Supports vanilla style:

    var model string
    //...
    switch model {
        case "dell":
            // Do something
        case "acer":
            // Do something else
        case "compaq":
            // Do something different
        default:
            // Do nothing
    }

However, unlike many langs go supports another switch-expressionless form:

    var velocity int
    //...
    switch {
        case velocity == 0 || velocity == 1:
            //...
        case velocity >= 10:
            //...
        case f(velocity) >= f(100):
            //...
    }

If fallthrough is required there are a couple of options:

    case velocity >= 10:
        //...
        fallthrough

Or pile up the case statements with multiple expressions:

    switch motion {
        case "walk", "run":

### for

The `for` keyword covers off all loop types in Go. No support for `while`, `do`, `until` loops exist.

-   For loop `for i=0; i<10; i++`
-   While loop `for i<10`
-   Infinite loop `for`
-   Enumerable iteration `for i, v := range s`

## I/O

### fmt

The `fmt` (fumpt) package does formatted I/O.

-   parameters are separated by spaces by default
-   it can handle a variety of input types
-   explicit argument indexes (one-based) are supported `fmt.Sprintf("%[2]d %[1]d\n", 11, 22)`

Supported [format verbs](https://golang.org/pkg/fmt/) are like C, but simpler.

-   `%v` value in default format
-   `%#v` print the value in valid Go syntax, handy for dumping structs or slices
-   `%t` boolean
-   `%d` base 10
-   `%b` base 2
-   `%x` base 16
-   `%s` raw string
-   `%T` type of the value

```go
r, g, b := 124, 87, 3
// ...as #7c5703  (specifying hex format, fixed width, and leading zeroes)
fmt.Printf("#%x%x%x\n", r, g, b)
// ...as rgb(124, 87, 3)
fmt.Printf("rgb(%d, %d, %d)\n", r, g, b)
// ...as rgb(124, 087, 003) (specifying fixed width and leading zeroes)
fmt.Printf("rgb(%03d, %03d, %03d)\n", r, g, b)
// ...as rgb(48%, 34%, 1%) (specifying a literal percent sign)
fmt.Printf("rgb(%d%%, %d%%, %d%%)\n", r*100/255, g*100/255, b*100/255)
// Print the type of r.
fmt.Printf("%v\n", r)
```

Reading input done with `fmt.Scan`, `fmt.Scanln` and `fmt.Scanf`

```go
var s string
var n int
cnt, err := fmt.Scan(&s, &n)
fmt.Println(cnt, s, n, err)
```

`Scanf` will parse input precisely as the format string specifies (in the snippet below: an 'a' character, followed by a space, a string, a newline, then an integer):

    fmt.Scanf("a %s\n%d", &label, &age)

Fuller example:

```go
var n1, n2, n3, n4 int
var f1 float64

// Scan the card number.
str1 := "Card number: 1234 5678 0123 4567"
_, err := fmt.Sscanf(str1, "Card number: %d %d %d %d", &n1, &n2, &n3, &n4)
if err != nil {
    fmt.Println(err)
}
fmt.Printf("%04d %04d %04d %04d\n", n1, n2, n3, n4)

// Scan the numeric values into a floating-point variable, and an integer.
str2 := "Brightness is 50.5% (hex #7ffff)"
_, err = fmt.Sscanf(str2, "Brightness is %f%% (hex #%x)", &f1, &n1)
if err != nil {
    fmt.Println(err)
}
fmt.Println(f1, n1)
```

### CLI

#### Args

-   complete command line is available via an array named `os.Args`
-   use `len()` to size `os.Args`
-   iterate over individual args with `range` like `for _, e := range os.Args`

#### Flags

A standard package for parsing CLI flags `./coolprog -verbose -count=7`

The `flag` package works by creating a pointer for each flag. Flags are then evaluated with `flag.Parse()`.

```go
verbose := flag.Bool("verbose", false, "Print verbose log outputs")
count := flag.Int("count", 1, "Number of items to collect")
flag.Parse()
fmt.Printf("verbose = %t, count = %d\n", *verbose, *count)
```

When working with the flag pointers, they need to be dereferenced with the `*` syntax.

By declaring variables explicitly can avoid the need to deref pointers:

```go
var max int
flag.IntVar(&max, "max", 1, "The maximum number of shares to buy on a triggered event")
```

POSIX flags support both short and long forms e.g. `-n --name`. There are many community packages that support this such as `pflag`.

# Types

## Type conversion

Many langs support type casting. Go provides conversion functions.

```go
var u uint = 64
var u64 unit64 = uint64(u)
```

When truncation is needed, go always rounds down towards zero.

## Strings

-   the `strings` package is where many string utility functions live for working with bytes (e.g. `strings.IndexByte`) and runes (e.g. `strings.IndexRune`)
-   the `strconv` package provides many conversions (such as `Atoi`, `Itoa`, `FormatInt`, `ParseBool`, `FormatFloat`, `ParseFloat`)
-   they immutable (mutability is possible using a slice of bytes)
-   treated as sequences of bytes with arbitrary values, even a null byte, differentiating them from C strings
-   substrings `s[1:4]` would return characters `his` in the below string (the second index hits the first byte after the substring)
-   substring shortcuts `s[:4]` and `s[4:]`

Sample string:

    | T | h | i | s |   |
      ^   ^   ^   ^   ^
      0   1   2   3   4

### Unicode

Make sure to learn about whats available in the [unicode](https://golang.org/pkg/unicode/) package. Many identification and conversion utilities such as `IsSpace` or `ToTitle` exist.

Go uses UTF-8 to encode unicode. Recall UTF-8 is a variable length encoding (i.e. it can use 1-byte or upto 4-bytes).

    fmt.Println(len("a")) // 1
    fmt.Println(len("Ã¤")) // 2
    fmt.Println(len("èµ°")) // 3

We can see the UTF-8 encoding in action here, with simple English characters using only a single byte, with the more esoteric characters using 2 or more bytes depending how deep into the unicode listing they fall.

Go allows you to treat string both a the byte and character level. At the character level, the unit of a character is called a `rune`. A `rune` is just an alias for a `int32`.

Runes are presented by `range` when iterating over a string:

```go
for i, e := range "abÃ¤èµ°." {
    fmt.Println("range:", i, e, string(e))
}

// range: 0 97 a
// range: 1 98 b
// range: 2 228 Ã¤
// range: 4 36208 èµ°
// range: 7 46 .
```

Strings can be worked with at both the byte and rune levels. UTF-8 generally makes this work out fine:

```go
fmt.Println("IndexByte:", strings.IndexByte("abÃ¤èµ°.", '.')) // IndexByte: 7
fmt.Println("IndexRune:", strings.IndexRune("abÃ¤èµ°.", 'èµ°')) // IndexRune: 4
```

The [unicode/utf8](https://golang.org/pkg/unicode/utf8/) package provides rune aware functionality, such as [RuneCountInString](https://golang.org/pkg/unicode/utf8/#example_RuneCountInString).

```go
str := "Hello, ä¸–ç•Œ"
fmt.Println("bytes =", len(str)) // bytes = 13
fmt.Println("runes =", utf8.RuneCountInString(str)) // runes = 9
```

Showcase of some `unicode` and `strings` functionality:

```go
import (
	"fmt"
	"os"
	"strings"
	"unicode"
)

func acronym(s string) (acr string) {
	afterSpace := false

	for i, e := range s {
		if (afterSpace || i == 0) && unicode.IsLetter(e) && unicode.IsUpper(e) {
			acr += string(e)
			afterSpace = false
		}
		if unicode.IsSpace(e) {
			afterSpace = true
		}
	}

	return acr
}

func main() {
	s := "Pan Galactic Gargle Blaster"
	if len(os.Args) > 1 {
		s = strings.Join(os.Args, " ")
	}
	fmt.Println(acronym(s))
}
```

### String literals

-   the usual `\t` tabs, `\n` newline
-   `\x61` is a raw byte in hex, evaluating to the character `a`
-   `\142` is a raw byte in octal
-   multi-line literals are supported using backticks

## Numbers

-   The `bool` type is strictly handled by go, and no auto-type conversion is supported (e.g. `if 1`).
-   Conditions can evaluate a boolean type, a comparison operation or a bool func.

### Integers

Go supports integers explicitly; their signage and size.

| Signed  | Unsigned | Bytes |
| ------- | -------- | ----- |
| `int8`  | `uint8`  | 1     |
| `int16` | `uint16` | 2     |
| `int32` | `uint32` | 4     |
| `int64` | `uint64` | 8     |

Several aliases to these types exist:

-   `byte` is a `uint8`
-   `rune` is a `int32`
-   `int` and `uint` are CPU platform specific

Arithmetic overflows are silently discarded.

```go
var a uint8 = 250
a = a + 10 // result is larger than 256, so a ends up being 4
```

### Bitwise operations

As the usuals, such as `a & b` for bitwise AND, `a >> n` right shift by n bits, `a &^ b` for a AND NOT b (aka bit clear, all the bits in b set to 1 will be cleared in the result), etc.

```go
// var a uint8 = 64
// uint8 is 8-bits wide, and looks like this at the bit level:
// | 256 | 128 |  64 |  32 |  16 |  8 |  4 |  2 |  1 |  0 |
// |   0 |   0 |   1 |   0 |   0 |  0 |  0 |  0 |  0 |  0 |
//
// bit shifting to the right 1 bit
// a = a >> 1
// | 256 | 128 |  64 |  32 |  16 |  8 |  4 |  2 |  1 |  0 |
// |   0 |   0 |   0 |   1 |   0 |  0 |  0 |  0 |  0 |  0 |

var a uint8 = 64
a = a >> 1 //32
```

### Floating point

-   Supports IEEE 754 real numbers with the `float32` and `float64` types.
-   Prefer `float64`
-   Decimal fractions cannot be accurately modelled using the binary system. Never use when accuracy is needed, such as for money calculations.

The float binary problem:

    $ bc
    bc 1.07.1
    obase=2
    scale=40
    1/10
    .0001100110011001100110011001100110011001100110011001100110011001100\
    110011001100110011001100110011001100110011001100110011001100110011

## Constants

Go supports typed and untyped constants, in either the singular or multiple forms.

Go constants can represent these types:

-   a unicode rune, `'ðŸ˜€'` `'\377'` `'\u266B'` `'\U0001F600'`
-   integers, as decimal `1337`, octal `01337`, or hex `0x1CAFE42`
-   floats `123.456e7`, `123e20`, `1.234`, `.71828`, `2.e7`, `.5e-10`
-   strings, any sequence of unicode runes or escape sequences, `"A string \U0001F600"`
-   booleans

Enumerations are possible with the `iota` keyword. Reassigning `iota` in the same list of consts has no effect.

```go
const kilo = 1024
const pi32 float32 = 3.1415926535897932384

const (
    cint = 299792458
    ctitle = "Theo de Raadt created OpenBSD in 1995 by forking NetBSD"
)


// all constants are set to 12
const (
    twelve = 12
    dozen
    months
)

const (
    zero = iota
    one
    two
    three
    four
)

// iota calculation
const (
    ten = iota * 10 + 10
    twenty
    thirty
)


// iota bit shifting
const (
    read    = 1 << iota  // 0001
    write                // 0010
    execute              // 0100
    isLink               // 1000
)
```

## Pointers

-   Supports C like `*type` pointer type, `&` address of, and `*p` pointer indirection
-   Pointers have a default value of `nil`
-   Its illegal to point to an arbitrary (literal) address, or a constant
-   When `nil`, pointer indirection causes a panic
-   Can compare pointer addresses `p1 == p2`, or the values they point to `*p1 == *p2`
-   The built-in `new()` allocates variable and returns a pointer to it `p := new(int)`

```go
var a int = 1
var p *int = nil

p = &a
fmt.Println("p's value is a's address", p)
```

# Vim setup

1. Install the [vim-go](https://github.com/fatih/vim-go) and [coc.nvim](https://github.com/neoclide/coc.nvim) plugins. I use neovim with vimplug to do this.
2. Setup `GOPATH` and `GOBIN` env.
3. Run `vim +GoInstallBinaries` to install supporting toolchain in `GOBIN`.
4. Setup coc config by running `:CocConfig` within vim. Ensure the language server is setup for go, using the provided snippet.
5. Jump into some go code such as [vmware-tanzu/velero](https://github.com/vmware-tanzu/velero), and test `gd` goto def, and `ctrl o` to bounce back. Cursor over some func and hit `:GoDoc` to show contextual docs.
6. Congrats, you have tight integration with go toolchain thanks to `vim-go`, but also modern language intelligence thanks to LSP, `gopls` and `coc-nvim`.

# Libraries

## Middleware

-   [negroni](https://github.com/urfave/negroni) idiomatic HTTP middleware
-   [alice](https://github.com/justinas/alice) painless middleware chaining

## Web

-   [gin](https://github.com/gin-gonic/gin) HTTP web framework
-   [go-jose](https://github.com/square/go-jose) implements the Javascript Object Signing and Encryption set of standards JWE, JWS and JWT (JSON Web Encryption, JSON Web Signature and JSON Web Token)
-   [gorilla](https://www.gorillatoolkit.org/) a general purpose web toolkit that solves doing context, routing, RPC over HTTP, strong typing forms to structs, secure cookies, session and websockets.
