---
layout: post
draft: true
title: "Redux"
slug: "redux"
date: "2020-04-29 12:04:16"
lastmod: "2020-04-29 12:04:16"
comments: false
categories:
  - dev
  - web
tags:
  - react
---

Once you start working with [React]({{< ref 2019-05-05-react.md >}}) in anger, there is a tipping point to be aware of where:

- the complexity of data flows piles up
- the same data is being rendered in multiple places
- the number of state changes blow out

Being able to tackle these problems in a single place is where Redux fits in.


# The Problem

Imagine a fairly deep component hierarchy, starting with your top level `App` component. Deep down the tree, there are two child components that need to access a common piece of data (e.g. customer data). How should these components access the data they require?

## Option 1 lift the state

This option involves placing the state (customer data) to the common ancestor in the component tree. In the worst case, this could be the top level component. It then becomes the burden of each decendent component to pass this state down as `props` (known as props drilling).

In a large app, this sucks.

- keeping track of what props are being passed around
- introducing new components between an existing *prop drilling* path


## Option 2 react context

React context exposes global data and functions from a given React component. To access this published state, a downstream component imports the context and consumes.

The common ancestor parent component, could publish customer data (and functions if desired) via `CustomerContext.Provider`.

The child components could consume this data via `CustomerContext.Consumer`.


## Option 3 Redux

Provides a centralised *store* (like a local client side DB).

Any component can connect and query the *store*.

To change (mutate) data in the store is not directly possible. Instead the requesting component dispatches an action, for example *Create Customer*, and the data is eventually updated/created. Any components connected to this data, automatically receieve it's freshest version.


# Container vs Presentation Components

Container (aka smart, stateful or controller view) components can be thought of as the _backend of the frontend_. They're concerned with behaviour and marshalling. They're typically stateful, as they aim to keep the child components fresly rendered with the latest data. A good container component should have very minimal (ideally zero) markup.

Presentation (dumb, stateless or view) components are purely concerned with markup, and contain almost no logic. They are dumb.

| **Container**               | **Presentation**                      |
| --------------------------- | ------------------------------------- |
| No markup.                  | All markup                            |
| Pass data and actions down. | Receive data and actions with `props` |
| Coupled tightly to Redux    | Zero knowledge of Redux               |
| Stateful                    | Stateless                             |

> When you notice that some components don't use props they receive but merely forward them down...it's a good time to introduce some container components â€” Dan Abramov



# The Redux Principles

1. One immutable store. It cant be changed directly. Immutability aids debugging, supports server rendering, and opens up the ability to easily centralise state functionality such as undo and redo.
2. Actions trigger changes. Components that wish to change state, do so by *dispatching* an action.
3. State changes are handled by pure functions, known as *reducers*.

Conceptually this is publish subscribe. The redux flow visually:

    +---------+
    | ACTION  |
    +----+----+
         |
         v
    +----+----+       +-----------+
    |  STORE  +<----->+  REDUCER  |
    +----+----+       +-----------+
         |
         v
    +----+----+
    |  REACT  |
    +---------+

## Actions

An action represents the intent via its `type` property, the only mandatory field. Other data can be encoded into the action however you please.

    { type: RATE_GYM, rating: 4 }

In this example, rating could be a complex object, a boolean, or there could be several more properties in addition to rating.

Typically actions are made with a factory method known as an *action creator*:

    rateGym(rating) {
      return { type: RATE_GYM, rating: rating }
    }

This is good practice as the consuming components don't need to know about the internals of action structures. For each entity type, its common to have a CRUD (create, retrieve, update, delete) set of *action creators*.


## The Store

A store is created in the entry point of your application (i.e. as it starts up):

    let store = createStore(reducer);

The store API is suprisingly simple:

- `store.dispatch(action)`
- `store.subscribe(listener)`
- `store.getState()`
- `replaceReducer(nextReducer)`


## Immutability

A cornerstone principle of redux, is that state is never modified (mutated), instead a completely new copy of the data is returned.

Benefits of immutable state:

- **Clarity** around what is responsible for state changes, everything has a clearly defined reducer. No more debugging trying to track down the piece of code responsible for mutating the state.
- **Performance** the job of Redux determining if a state change has occured and notifying React is greatly simplified with an immutable store. Instead of doing complex field level comparisons of each data element before and after, all Redux needs to do is a `prevStoreState !== storeState` check.
- **Unrivalled state debugging** because state is never mutated, allows for some incredible innovation in the debugging experience, such as time-travel debugging, undo/redo, skipping individual state actions, replaying the state interactions back.

Building complex objects up by hand each time a modification is needed, is not practical. JS does provide a number of ways to copy an object:

- Object.assign shallow copy. `Object.assign({}, state, { role: 'admin' })` assigns a new empty object based on the existing `state` object, after mixing-in the new `role` property.
- The spread operator, whatever is placed on the right is shallow copied `const newState = { ...state, role: 'admin' }`
- Immuatable friendly Array methods, such as `map`, `filter`, `reduce`, `concat` and `spread`. Avoid `push`, `pop` and `reverse` which mutate.

There is a large ecosystem of libraries available (immer, seamless-immutable, react-addons-update, Immutable.js) for working with data in an immutable compatable way, one popular option is [immer](https://github.com/immerjs/immer):

> Create the next immutable state tree by simply modifying the current tree

```javascript
import produce from "immer"

const user = {
  name: "Benjamin",
  address: {
    state: "New South Wales"
  }
};

const userCopy = produce(user, draftState => {
  draftState.address.state = "Victoria"
});

console.log(user.address.state); // New South Wales
console.log(userCopy.address.state); // Victoria
```


Options for enforcing immutability:

1. Trust the development team, through training and coding practices.
2. Warn whenever state is mutated using `redux-immutable-state-invariant` (only use in development!)
3. Enforce with the use of a library such as immer, immutable.js or seamless-immutable.


## Reducers

An action is eventually handled by a reducer. Metaphorically the reducer is the meat grinder of Redux, state goes in, state comes out.

    function myReducer(state, action) {
      switch (action.type) {
        case "INCREMENT_COUNTER":
          //state.counter++; //BAD: never mutate
          //return state;
          return { ...state, counter: state.counter + 1 };
        default:
          return state;
      }
    }

If and when the state is returned by a reducer, the store is updated.

Reducers must be pure. In other words a reducer must:

- Never mutate state
- Perform side effects, such as API calls or routing transitions
- Call non-pure functions (e.g. `Date.now`, `Math.random()`)

Therefore for a given input, and reducer is guaranted to alway return the same output.

When a dispatch is submitted, ALL reducers are invoked. That's why its important for the untouched `state` to be returned as the default case of the switch statement.

A reducer should be independent and responsible for updates to a slice of state, however there are no hard and fast rules.

Each action can be handled by one or more reducers.

Each reducer can handle multiple actions.


Any React components that a glued up to the store are automatically updated, via a push notification using React-Redux.