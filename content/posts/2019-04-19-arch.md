---
layout: post
title: "Arch Linux"
date: "2019-04-06 11:32:10"
comments: false
categories:
- linux
tags:
- archlinux
- dwm
- st
---


After seeing a tiling window manager in action on a very minimal disttribution, I knew it was my time to take the pilgrimage to Arch.

As a long time Linux fanatic I'd never really taken the time to understand what makes Arch different from other distributions.

* [The Arch Way](https://wiki.archlinux.org/index.php/Arch_terminology#The_Arch_Way)
* Forces one to build the system up by hand.
* This encourages you to question each piece of the system.
* The result is a highly tailored and minimal system that meets precisely your needs.
* The Arch User Repository (AUR) is a treasure chest of pre-packaged useful recent software. Somehow every program I've ever needed has been available on AUR.
* Rolling upgrades.
* Practical and pragmatic documentation. The [Arch Wiki](https://wiki.archlinux.org/) is the gold standard when it comes to documentation.


# Pre Install

## Boot disk

To bootstrap the install process, a boot key is the way to go. Obtain the latest `iso` image, and block write it to a USB drive using `dd`. `dd` (aka disk destroyer to some) trusts you know what you're doing and can destroy data very easily if not used correctly.

Use `lsblk` to determine the mapped device name (e.g. `/dev/sdb`). When ready, pull the trigger and flash the drive with arch:

    dd if=Downloads/archlinux-2019.03.01-x86_64.iso of=/dev/sdb status="progress"

Boot the target system on the new boot drive. If all goes well, you will end up on a bash shell, in the temporary boot preparation system provided by Arch.



## Post boot

Get network connectivity:

    wifi-menu
    ip a

Enable NTP:

    timedatectl set-ntp true




## Partitioning

UEFI (supports newer 64-bit based GPT) or BIOS (based on traditional MBR). If the below sys node doesn't exist, go BIOS:

    ls /sys/firmware/efi/efivars

Determine the target block device (e.g. an SSD) for installation, using `lsblk`.

Assuming a BIOS compatible system, will go with `fdisk` (not `gdisk`) for the partitioning setup:

    fdisk /dev/sda

`fdisk` shortcuts:

- `m` help
- `p` print partition table
- `d` delete
- `n` new

In a nutshell, blow away any existing partitions (`d`), and create 4 new (`n`) primary partitions. Note when specifying the *last sector* can size with `+200M` style syntax, `+200M` is 200MiB, `+50G` is 50GiB. I cut my ~500GB drive up into the following 4 partiions:

- 200M for *boot* partition (grub etc)
- 24G for *swap* (rule of thumb is 150% of total system memory)
- 100G for *root* partition
- ~340G+ for *home* partition (leave last sector unspecified in fdisk to use all remaining space)


We are aiming for a partition layout similar to this:

    $ lsblk            
    NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
    sda      8:0    0 465.8G  0 disk 
    ├─sda1   8:1    0   200M  0 part /boot
    ├─sda2   8:2    0    24G  0 part [SWAP]
    ├─sda3   8:3    0   100G  0 part /
    └─sda4   8:4    0 341.6G  0 part /home



## Format partitions (file systems)

Apply `ext4` (the fourth extended filesystem) to the boot, root and home partitions (i.e. all but the swap):

    mkfs.ext4 /dev/sda1
    mkfs.ext4 /dev/sda3
    mkfs.ext4 /dev/sda4

Then setup the swap space:

    mkswap /dev/sda2
    swapon /dev/sda2




# Mount partitions

Now its time to mount these new partitions into the Arch bootstrapped system, so they be used.

The four partitions will be mounted into the current Arch boot preparation systems file system tree under `/mnt` so a `chroot` can occur, and then system installation. First mount the root partition, then the *boot* and *home* partitions within the *root* mount under `/mnt/boot` and `/mnt/home` respectively.

    mount /dev/sda3 /mnt
    mkdir -p /mnt/boot /mnt/home
    mount /dev/sda1 /mnt/boot
    mount /dev/sda4 /mnt/home




# Installation


## Setup pacman mirrors

Defined in `/etc/pacman.d/mirrorlist`. Higher mirrors in the list taken precedence over lower once, rearrange as desired:

    ##
    ## Arch Linux repository mirrorlist
    ## Filtered by mirror score from mirror status page
    ## Generated on 2019-04-01
    ##
    
    ## Australia
    Server = http://mirror.internode.on.net/pub/archlinux/$repo/os/$arch
    ## Turkey
    Server = http://mirror.veriteknik.net.tr/archlinux/$repo/os/$arch



## Install Arch with pacstrap

The `pacstrap` script will install the `base`, and if desired other [package groups](https://www.archlinux.org/groups/x86_64/), such as [base-devel](https://www.archlinux.org/groups/x86_64/base-devel/) for common build related programs.

    pacstrap /mnt base base-devel





# Configuration

## fstab

So that the mount are automatically applied as part of the system boot process, add them to `/etc/fstab` as UUID's, which are more robust than device names which can change.

    genfstab -U /mnt >> /mnt/etc/fstab

## chroot

Now to change root into the new system, from the Arch boot preparation system:

    arch-chroot /mnt


## root password

Set the password for the root account with `passwd`


## Localisation

Uncomment `en_US.UTF-8` and `UTF-8` in `/etc/locale.gen`, and generate:

    locale-gen

Create `/etc/locale.conf` with:

    LANG=en_US.UTF-8


## Time zone

Symlink in the appropriate zone definition:

    ln -sf /usr/share/zoneinfo/Australia/Canberra /etc/localtime

Run `hwclock --systohc` to generate `/etc/adjtime`



## Networking

- Create `/etc/hostname`, and define a name for the host.
- Edit `/etc/hosts` for loopback based on the defined hostname above, `127.0.1.1	myhostname.localdomain	myhostname`
- Install NetworkManager which provides persistent network configuration across reboots, `pacman -S networkmanager` and enable it `systemctl enable NetworkManager`



## Boot loader (GRUB)

Several boot loaders are [supported](https://wiki.archlinux.org/index.php/Arch_boot_process#Boot_loader) but here are going with GRUB.

    pacman -S grub
    grub-install --target=i386-pc /dev/sda
    grub-mkconfig -o /boot/grub/grub.cfg



# Reboot

A minimal base system is installed and configured, and ready to be used.

- Escape chroot with ctrl+d or `exit`.
- Unmount everything `umount -R /mnt`, `lsblk` should confirm this.
- `reboot`
- Remove the USB drive



# Post boot


## Fix wifi

Unfortunately wifi settings were not persisted. Fix with:

    nmcli dev wifi connect wifi-sid-goes-here password wifi-password-goes-here

Also make sure to that `wifi-menu` is functional, by installing the `dialog` package. `netctl` is useful for troubleshooting. Ensure that the network profile for the wifi is enabled using `netctl`.

## Add users

    useradd -m -g wheel ben
    passwd ben
    sudo vi /etc/sudoers

Uncomment (line 85) to allow members of the wheel group to sudo with (or without) password prompting:

    %wheel ALL=(ALL) NOPASSWD: ALL


## Desktop Environment (DE) vs Window Manager (WM)

In a nutshell a DE (like gnome or kde) is heavy weight includes everything bar the kitchen sink, such as music players, document editors, file managers, status bars, network managers, start menus, etc. They are incredibly bloated, but aimed at novice users that just want their computer "to work". A WM (like dwm or i3) on the other hand is incredibly lean, I mean you don't even get a status bar, but are very customisable and do just what you want and no more. Because of this WM's tend to be allot snappier. I personally prefer using a WM, and more specifically a tiling WM (aka a *tiler*) and highly recommend [dwm](https://dwm.suckless.org/):

> Because dwm is customized through editing its source code [C], it's pointless to make binary packages of it. This keeps its userbase small and elitist. No novices asking stupid questions.

I have started to form some of my own opinions around the use of a tiler:

* Gaps between windows are literally a waste of space. Don't do this.
* Don't bother with lots of the cosmetic ricing hacks out there, its all bloat.
* Toolbars (such as `polybar`) display redundant information at the cost of cognitive overload and wasted screen real-estate. If I want to know the time I look at my watch.


### dwm

I've have recently discovered [suckless](https://suckless.org/), and their [philosophy](https://suckless.org/philosophy/) towards software really resonates strongly with me.

> We are the home of quality software such as dwm, dmenu, st and plenty of other tools, with a focus on simplicity, clarity and frugality. Our philosophy is about keeping things simple, minimal and usable.

`dwm` is their minimal tiling window manager.

> Because dwm is customized through editing its source code, it's pointless to make binary packages of it. This keeps its userbase small and elitist. No novices asking stupid questions.

    pacman -Sy xorg-server xorg-xinit
    pacman -Sy xf86-video-amdgpu
    pacman -Sy dmenu git

Clone the `dwm` Git repo, and my patches:

    git clone https://git.suckless.org/dwm
	git clone https://github.com/bm4cs/dotfiles.git
	cd ~/dotfiles && ./install.sh

Apply patches:



Build and install:

    make && sudo make install

To autostart `dwm`:

Edit `~/.xinitrc` with following:

    exec dwm

Then `startx`. A black screen desktop should appear. This is good.

### i3-gaps

`i3-gaps` is a fork of the excellent `i3wm` tiling window manager. As its name implies it supports placing gaps (i.e. regions of space) between the tiled windows, providing a very neat and satisfying perseption of order when windows are automatically laid out.

![i3-gaps in action](/images/i3-snap.jpg "i3-gaps in action")


    pacman -S xorg-server xorg-xinit
    pacman -S xf86-video-amdgpu
    pacman -S i3-gaps i3status rxvt-unicode dmenu

To autostart i3:

Edit `~/.xinitrc` with following:

    exec i3

Then `startx`. A black screen desktop should appear. This is good.


## Essential applications

If you've gone down the window manager route, there is literally nothing. Given nothing is installed, here are some nice lightweight options I use:

My 2c, make sure to consider [suckless](https://suckless.org/) programs.

* AUR helper: `yay`
* Audio: `alsamixer`, `alsa-utils`, `pulseaudio`, `pulseaudio-alsa`, `pulsemixer`
* Bluetooth: `bluez`, `bluez-utils`, `pulseaudio-bluetooth`
* Database: `postgres`
* Developer: `gcc`, `python`, `golang`, `java`
* Document authoring: `pandoc`, `texlive-core`, `texlive-bin`, `texlive-latexextra`, `texlive-publishers`, `texlive-fontsexta`, `troff`, `pdflatex`
* DVD/CD burning: `dvd+rw-tools`, `cdrtools`, `lame`
* Games: `steam`, `nethack`
* Fonts: `ttf-font-awesome`, `powerline-fonts`, `adobe-source-code-pro-fonts`, `noto-fonts-cjk`, `noto-fonts-emoji`, `noto-fonts`, `ttf-freefont`, `ttf-ms-fonts`, `ttf-linux-libertine`, `ttf-dejavu`, `ttf-inconsolata`, `ttf-ubuntu-font-family`
* File manager: `nnn`
* Hypervisor (VM's): `vbox`
* Image viewer: `sxiv`
* IRC client: `irssi`
* Mail: `neomutt`, `mw`
* Music player: `mpd`, `mpc`, `ncmpcpp`
* Network manager: `wifi-menu`, `dialog`
* Notifications: `dzen2`
* PDF viewer: `mupdf`
* Screenshots: `maim`, `xclip`
* Shells: `dash`, `zsh`
* Terminal emulator: `st`
* Text editor: `nvim`
* Video player: `vlc`
* VPN: `openvpn`
* Window manager: `dwm`, `i3`



## i3 ricing

> The term ricing originates from the auto enthusiast community, and was used predominantly as a perjorative to describe people who make modifications to their (usually Japanese) cars that add visual flair, but don't improve performance. In the context of unixporn, it means customizing your desktop to make it look snazzy.

This rice was used on `i3`. While I enjoyed my brief time using this excellent tiler, I have moved to using suckless `dwm`. While these ricing hacks should apply to both, I havent verified.

### Wallpaper

    pacman -S feh

Add a task runner to `~/.config/i3/config` to always set the wallpaper whenever i3 runs.

    exec_always --no-startup-id feh --bg-scale /home/ben/Pictures/Wallpapers/nature3.jpg

### Sound

    pacman -S alsa-utils

Can now run `alsamixer` to manage the sound card.

### Load Xresources at startup

Need to customise the appearance of apps like `urxvt`.

    exec_always --no-startup-id xrdb -load ~/.Xresources

If you dont have a `~/.Xresources` of your own, checkout my [dotfiles](https://github.com/bm4cs/dotfiles).


### Making GTK and QT apps pretty

    pacman -S lxappearance gtk-chtheme gtk-engine-murrine gtk-engines gnome-themes-extra qt5ct

Define the following environment variables to override default QT styling:

    export QT_STYLE_OVERRIDE=adwaita
    export QT_QPA_PLATFORMTHEME="qt5ct"
    export QT_AUTO_SCREEN_SCALE_FACTOR=0





# Conclusion

This is a worth while endevour to take. I now have a very tailored system that works exactly how I want, without any bloat, and its FAST. Finally if interested, all my configuration from vim to urxvt to i3 is in my [dotfiles](https://github.com/bm4cs/dotfiles) git repo.

I've have recently discovered [suckless](https://suckless.org/), and their [philosophy](https://suckless.org/philosophy/) towards software really resonates strongly with me.

> We are the home of quality software such as dwm, dmenu, st and plenty of other tools, with a focus on simplicity, clarity and frugality. Our philosophy is about keeping things simple, minimal and usable.


